{"_id":"fuzzaldrin-plus","_rev":"1-9950208ab718a221b8ed67046da3a3bb","name":"fuzzaldrin-plus","description":"Fuzzy filtering and string scoring - compatible with fuzzaldrin","dist-tags":{"latest":"0.1.0"},"versions":{"0.1.0":{"name":"fuzzaldrin-plus","version":"0.1.0","description":"Fuzzy filtering and string scoring - compatible with fuzzaldrin","licenses":[{"type":"MIT","url":"https://github.com/jeancroy/fuzzaldrin-plus/raw/master/LICENSE.md"}],"main":"./lib/fuzzaldrin.js","scripts":{"prepublish":"grunt prepublish","test":"grunt test","benchmark":"coffee benchmark/benchmark.coffee"},"repository":{"type":"git","url":"https://github.com/jeancroy/fuzzaldrin-plus.git"},"bugs":{"url":"https://github.com/jeancroy/fuzzaldrin-plus/issues"},"homepage":"https://github.com/jeancroy/fuzzaldrin-plus","keywords":["fuzzy","approximate","string","matching","filter","search","highlight","sublime"],"devDependencies":{"jasmine-focused":"1.x","grunt-contrib-coffee":"~0.9.0","grunt-cli":"~0.1.8","grunt":"~0.4.1","grunt-shell":"~0.2.2","grunt-coffeelint":"0.0.6","coffee-script":"~1.7"},"gitHead":"bbb777204ac47dcf8a0c9dfc8b3761542abbedff","_id":"fuzzaldrin-plus@0.1.0","_shasum":"bac85708286a6471e162dc6b546fc06ce3c3f310","_from":".","_npmVersion":"2.7.4","_nodeVersion":"0.12.2","_npmUser":{"name":"jeancroy","email":"jcking@gmail.com"},"dist":{"shasum":"bac85708286a6471e162dc6b546fc06ce3c3f310","tarball":"http://registry.npmjs.org/fuzzaldrin-plus/-/fuzzaldrin-plus-0.1.0.tgz"},"maintainers":[{"name":"jeancroy","email":"jcking@gmail.com"}],"directories":{}}},"readme":"## What Problem are we trying to solve ?\r\n\r\n### Score how matched characters relates to one another.\r\n\r\n- One of the most complained thing is not being able to find exact match.\r\n- A great source of questionable results come from scattered character, spread a bit randomly in the string.\r\n\r\nAnd we plan to address those issues by scoring run of consecutive characters.\r\nExact match will be a special case where the run is 100% of the query length.\r\n\r\nUp to now match length was used as a proxy for quality. This work reasonably well when subject is a single word, but break when subject contain multiple words, for example see:\r\n\r\n- **Core**\r\n- **Co**nt**r**oll**e**r\r\n- Extention**Core**\r\n\r\nIn `Core` vs `Controller` size is a good indicator of quality, but not so much in `Controller` vs `ExtentionCore`. This is because match compactness mater more than haystack size.\r\n\r\n\r\n#### Run length / consecutive\r\n\r\nSo far the examples can be handled by an `indexOf` call. However there are times where a single query can target multiple part of an candidate.\r\n\r\nFor example when candidate contain multiple words\r\n- `git push` vs `Git Plus: Push`\r\n- `email handler` vs `email/handler.py`\r\n\r\nAnother example is to jump above common strings. \r\n- `toLowerCase`\r\n- `toLocaleString`\r\n- `toLocalLowerCase`\r\n\r\nWe could use a query like `tololo`  to select the third option of these.\r\n\r\n\r\n### Select character based on score.\r\n\r\nThe current algorithm always select the first available matching character (leftmost alignment) then try to identify how it should be scored. The problem is that the most interesting instance of a character is not necessarily on the left.\r\n\r\nFor example on query `itc`, we should match\r\n-  **I**mportance**T**able**C**trl.\r\n\r\nInstead leftmost aligement miss the acronym pattern \r\n- **I**mpor**t**an**c**eTableCtrl.\r\n\r\nFor query `core` against `controller_core` leftmost alignment miss the consecutive run    \r\n- **co**nt**r**oll**e**r_core \r\n\r\nTo handle this we propose to setup the max run-length scoring inside an optimal alignment scheme. (Implemented for example using dynamic programming)\r\n\r\n### Accidental acronym bonus.\r\n\r\nFuzzladrin handle acronym by giving a large per character bonus.  Currently a start of word bonus match almost as much as 3 proper case character (or 7 wrong case ones!)\r\n\r\nFor query install \"install\" should result be in this order ?\r\n- F**in**d & Replace **S**elec**t** **All**\r\n- Application: **Install**\r\n\r\nHere we have '**S**elect **A**ll' boost the score of the first candidate because we match two word-start VS only one for 'install'.\r\n\r\nFor query \"git push\", should we order result in that order ?\r\n- \"**Git** **P**l**u**s: **S**tage **H**unk\" \r\n- \"**Git** Plus: **Push**\" \r\n\r\nWhat about the fact we match 3 start-of-word in `Plus Stage Hunk` ? PSH is very close to '**p**u**sh**'. \r\n\r\nThat kind of question arise even more often with optimal selection because the algorithm will lock on those extra acronym points.\r\n\r\nWhat we propose in this PR is that word start-of-word character only have a moderate advantage by themselves. Instead they form strong score by making an acronym pattern with other start-of-word character.\r\n\r\nFor example with query `push`:\r\n- match against `Plus: Stage Hunk`, we have P + u + SH so group of 1+1+2\r\n- match against `push` single group of 4.\r\n- The substring win for having the largest group\r\n\r\nFor example with query `psh`:\r\n- match against `Plus: Stage Hunk`, we have PSH so group of 3\r\n- match against `push`, we have p+sh so group of 1+2\r\n- The acronym win for having the largest group.\r\n\r\n \r\nThis way we can score both substring and acronym match using the structure of the match. We'll refine the definition of consecutive acronym later.\r\n\r\n\r\n### Score the context of the match.\r\n\r\nSome people proposed to give perfect score to exact case sensitive match. This can be understood because exact match and consecutive are two area where fuzzaldrin is not great.\r\n\r\nHowever should 'sw**itc**h.css' be an exact match for `itc` ? \r\nEven when we have **I**mportance**T**able**C**trl available ?\r\n\r\nFew people will argue against \"diag\" preferring \"diagnostic\" to \"Diagnostics\".\r\n\r\nHowever should `install` prefer \"Un**install**\" over \"**Install**\" ? Or should it be the other way around ?  This is a case of case-sensitive match vs start-of-word ...\r\n\r\n\r\n## Proposed scoring\r\n\r\n\r\n### 1. Characters are chosen by their ability to form pattern with others.\r\n\r\nPattern can be made of \r\n - consecutive letter of the subject, \r\n - consecutive letter of the Acronym of subject. \r\n\r\nStart-of-word (acronym) character are special in that they can either make pattern with the rest of the word or other acronym character.\r\n\r\n- This replace a situation where acronym character had unconditional large bonus. Now the bonus is still large but conditional to being part of some pattern.\r\n\r\n- CamelCase and snake_case acronym are treated exactly the same. They will however get different point for matching uppercase/lowercase query\r\n\r\n\r\n### 2. Primary score attribute is pattern length.\r\n\r\n- A pattern that span 100% of the query length is called an exact match.\r\n \t- There is such a thing as an acronym exact match.\r\n\r\n- Because every candidate is expected to match all of query larger group should win against multiple smaller one.\r\n    - Rank of a candidate is the length of it's largest pattern. \r\n    - When every pattern in a candidate are larger than pattern in a second one, highest rank candidate is said to be dominant.\r\n        - 1 group of 6 >  2 group of 3 > 3 group of 2.\r\n        \r\n\t- When some group are larger and some are smaller, highest rank match is said to be semi-dominant.\r\n         - group of 4+2 vs 2 groups of 3. Group of 4 wins agains the first group of 3, group of 2 loose against second group of 3.\r\n\r\n### 3. Secondary score attribute is match quality.\r\n  \r\n- Match quality is made of proper-casing and context score\r\n    - Main role of match quality is to order candidate of the same rank.\r\n    - When match is semi-dominant match quality can overcome a rank-1 difference.\r\n\r\n- Context score consider where does the match occurs in the subject.\r\n\t- Full-word > Start-of-word > End-of-word > Middle-of-word\r\n\t- On that list, Acronym pattern score at Start-of-word level. (That is just bellow full-word)\r\n\r\n- Proper case is both gradual and absolute.\r\n   - The less error, the better\r\n   - 100% Case Error will be called wrong-case, for example matching a CamelCase acronym using lowercase query.  \r\n   - Exactly 0 error is called CaseSentitive or ExactCase match. \r\n     They have a special bonus smaller than start-of-word bonus but greater than end-of-word bonus.\r\n     - This allow a start-of-word case sentitive match to overcome a full-word wrong-case match.\r\n     - Also allow to select between a lowercase consecutive and CamelCase acronym using case of query.\r\n     - Make \"Installed\" win over \"Uninstall\" because  start-of-word > Exact Case.\r\n       \r\n- **Q:** Why can't you simply add extra length. For example add an extra virtual character for a start-of-word match.\r\n   - **A:** We cannot do that on partial match because then the optimal alignment algorithm will be happy to split word and collect start-of-word bonus like stamp. (See accidental acronym)\r\n\r\n- **Q:** Why do you still do it on exact match ?\r\n   - **A:** First once you have matched everything there's no danger of splitting the query, then it's there for exact match to bubble up, despite longer/deeper path. If after more test/tuning we realize it's not needed, we'll be happy to remove it, the less corner case the merrier.\r\n\r\n- **Q:** Why are you using lowecase to detect CamelCase ?\r\n  - **A** CamelCase are detected as a switch from lowercase to UPPERCASE. Defining UPPERCASE as not-lowercase, allow case-invariant character to count as lowercase.   A lot of case invariant character are also separator, some are not such as number, and symbol such as `:!=<>()` \r\n\r\n### 4. Tertiary score attributes are subject size, match position and directory depth\r\n\r\n- Mostly there to help order match of the same rank and match quality, unless the difference in tertiary attribute is large. \r\n \t-(Proper definition of large is to be determined using real life example)\r\n\r\n- In term of importance of effect it should rank start-of-string > string size > directory depth.\r\n\r\n\r\n-------------\r\n\r\n### Acronym Prefix\r\nMore detail on acronym match\r\n\r\n\r\nThe acronym prefix is a group of character that are consecutive in the query and sequential in the acronym of the subject.\r\nThat group start at the first character of the query and end at the first error (character not in acronym). \r\nIf there's no error we have an acronym exact match (100% of query is part of acronym)\r\n\r\n\r\n**For example if we match `ssrb` against `Set Syntax Ruby` we'll score it like so**\r\n\r\n````\r\n  012345678901234\r\n \"Set Syntax Ruby\"\r\n \"000 SSR0b0 0000\"\r\n````\r\n\r\n- Acronym scored as start-of-word consecutive rank 3 + an isolated letter.\r\n- Here we have a wrong-case match. \"SSRb\" or \"SSRB\" would have case-sensitive points on the acronym pattern (case of isolated letter is not important)\r\n- Position of the equivalent consecutive match is the average position of acronym characters.\r\n- Size of the candidate does not chance.\r\n\r\n\r\n**Another example is matching `gaa` against `Git Plus: Add All` we'll score it like so**\r\n\r\n````\r\n  01234567890123456\r\n \"Git Plus: Add All\"\r\n \"000000 GAA00 0000\"\r\n````\r\n\r\n- here we conveniently allow to skip the `P` of `Plus`.\r\n\r\n\r\n**Then what about something like \"git aa\" ?**\r\n\r\nThis is a current limitation. We do not support acronym pattern outside of the prefix. Mostly for performance reason.\r\nAcronym outside of the acronym prefix will have some bonus, scoring between isolated character and 2 consecutive.\r\nThere are multiple thing we can improve if one day we implement a proper multiple word query support, and this is one of them.\r\n\r\n### Optional characters\r\n\r\nLegacy fuzzaldrin had some support for optional character (Mostly space, see `SpaceRegEx`). Because the scoring do not support errors, the optional character where simply removed from the query.\r\n\r\nWith this PR, optimal alignment algorithm support an unlimited number of errors. The strict matching requirement is handled by a separate method `isMatch`. The optional character implementation is done by building a subset of query containing only non-optional character (`coreQuery`) and passing that to `isMatch`.\r\n\r\nThis new way of doing thing means that while some characters are optional, candidate that match those characters will have better score. What this allow is to add characters to the optional list without compromising ranking.\r\n\r\nCharacter that has been added include `-` and `_` because multiple  specs require that we should threat them as space. Also `\\` and `:` to support searching a file by PHP and Ruby name-space. Finally `/` to mirror `\\` and support a better work flow in a multi-OS environment. \r\n\r\nFinally option `allowErrors` would make any character optional. Expected effect of that would be spell-checker like, but slower match.\r\n\r\n\r\n### Path scoring\r\n\r\n- Score for a path is made of about half score of full path and half score of basename.\r\n\r\n- Exact balance between those two set by the directory dept, there is less retrieval effect (importance of basename) for deeper directory\r\n\r\n- Full path is penalized twice for size. Once for it's own size, then a second time for size of the basename. This address various demand for shorter basename to win. Extra basename penalty is dampened a bit.\r\n\r\n- Basename is scored as if `allowErrors` was set to true. (Fullpath must still pass `isMatch` test) This allow to support query such as `model user` against path `model/user`. Previously, the basename score would be 0 because it would not find `model` inside basename `user`. Variable `queryHasSlashes` sort of addressed this issue, but was inconsistent with usage of `<space>` as folder separator \r\n\r\n- When query has slashes (`path.sep`) the last or last few folder from the path are promoted to the basename. (as many folder from the path as folder in the query)\r\n\r\n\r\n\r\n-------------\r\n\r\n## Performance\r\n\r\n### Hit Miss Optimization.\r\n\r\nA hit occurs when character of query is also in the subject.\r\n - Every (i,j) such that subject[i] == query[j], in lowercase.\r\n\r\nA missed hit occurs when a hit does not improve score.\r\n\r\nTo guarantee optimal alignment, every hit has to be considered.\r\nHowever when candidate are long (deep path) & query contains popular character (vowels) , we can spend a huge amount of time scoring accidental hit. \r\n\r\nSo we use number of missed hit as a heuristic for unlikely to improve.\r\nLet's score `itc` vs `ImportanceTableControl`\r\n\r\n- `I` of `Importance`: First occurrence, improve over none.\r\n- `t` of `Importance`: First occurrence, improve over none.\r\n- `c` of `Importance`: First occurrence, improve over none.\r\n- `T` of `Table` : Acronym match, improve over isolated middle of word.\r\n- `C` of `Control` : Acronym match, improve over isolated middle of word.\r\n- `t` of `Control`: no improvement over acronym `T`: first hit miss.\r\n\r\n- After a certain threshold of hit miss we can consider it's unlikely the score will get better \r\n- Despite above example hit miss optimization do not affect scoring of exact match (sub-string or acronym)\r\n- There are some legitimate use for hit miss, for example while scoring query `Mississippi` each positive match for `s` or `i` may trigger up to 3 hit miss on the other occurrence of that letter in query.\r\n\r\n- For that reason we propose counting consecutive hit miss and having maximum one hit miss per character of subject.\r\n\r\n**Q:** Does this grantee improvement over leftmost alignment ?\r\n**A:** It'll often be the case but no guarantee on pathological match.\r\n For example, in query `abcde` against candidate '**abc**abcabcabcabcabcabc_de' we may trigger the miss count before matching `de`. It'll still be registered as a match and probably a good one with `abc` at the start, `de` will be scored as optional characters not present. \r\n\r\nCandidate  'abcabcabcabcabcabc**abcde**' will not have any problem because it does not affect exact match. \r\n\r\nReal example is searching `index` in the benchmark. Where `i`, `n`, `d`, `e` exist scattered in folder name, but x exist in the extension `.txt`. However the whole point of this PR is to prefer structured match to scattered one so this might not be a problem.\r\n\r\n### High Positive count mitigation\r\n**[option `maxInners`, disabled by default]**\r\n\r\nA lot of the speed of this PR come from the idea that rejection happens often and we need to be very efficient on them to offset slower higher quality match. Unfortunately some query will match against almost everything.\r\n\r\n- Fast short-circuit path for exact substring acronym help a lot.\r\n- Missed hit heuristic also help a lot for general purpose match.\r\n\r\nHowever we may still be too slow for interactive time query on large data set. This is why `maxInners` option is provided.\r\n\r\nThis is the maximum number of positive candidate we collect before sorting and returning the list.\r\n\r\nThe realization is that a query that match everything on a 50K item data set is unlikely to show anything useful to the user above the fold (say in the first 15 results). \r\n\r\nSo then the priority is to detect such case of low quality (low discrimination power) query and report fast to the user so user can refine its query.\r\n\r\nA `maxInners` size of about 20% of the list works well. It is not needed on smaller list.\r\n\r\n\r\n### Benchmark\r\n- All test compare this PR to previous version (legacy)\r\n\r\n- The first test `index` is a typical use case, 10% positive, 1/3 of positive are exact match.\r\n  - We are about 2x faster\r\n\r\n- Second test `indx` remove exact matches. Just under 2x faster\r\n\r\n- Third test `walkdr`, 1% positive, mostly testing `isMatch()`, above 2x faster.\r\n\r\n- Fourth test `node`, exact match, 98% positive, bit under 2x faster.\r\n\r\n- Test 5 `nm`, exact acronym match, 98% positive, about 10% slower.\r\n\r\n- Test 6 `nodemodules` is special in that it use a string that score on almost every candidate, often multiple time per candidate and individuals characters are popular. It also avoid exact match speed-up.\r\nAbout 2x slower, but unlikely to happens in real life. `maxInners` mitigation cover that case.\r\n````\r\nFiltering 66672 entries for 'index' took 62ms for 6168 results (~10% of results are positive, mix exact & fuzzy)\r\nFiltering 66672 entries for 'index' took 120ms for 6168 results (~10% of results are positive, Legacy method)\r\n======\r\nFiltering 66672 entries for 'indx' took 69ms for 6192 results (~10% of results are positive, Fuzzy match)\r\nFiltering 66672 entries for 'indx' took 126ms for 6192 results (~10% of results are positive, Fuzzy match, Legacy)\r\n======\r\nFiltering 66672 entries for 'walkdr' took 30ms for 504 results (~1% of results are positive, fuzzy)\r\nFiltering 66672 entries for 'walkdr' took 70ms for 504 results (~1% of results are positive, Legacy method)\r\n======\r\nFiltering 66672 entries for 'node' took 112ms for 65136 results (~98% of results are positive, mostly Exact match)\r\nFiltering 66672 entries for 'node' took 213ms for 65136 results (~98% of results are positive, mostly Exact match, Legacy method)\r\n======\r\nFiltering 66672 entries for 'nm' took 60ms for 65208 results (~98% of results are positive, Acronym match)\r\nFiltering 66672 entries for 'nm' took 56ms for 65208 results (~98% of results are positive, Acronym match, Legacy method)\r\n======\r\nFiltering 66672 entries for 'nodemodules' took 602ms for 65124 results (~98% positive + Fuzzy match, [Worst case scenario])\r\nFiltering 66672 entries for 'nodemodules' took 123ms for 13334 results (~98% positive + Fuzzy match, [Mitigation])\r\nFiltering 66672 entries for 'nodemodules' took 295ms for 65124 results (Legacy)\r\n````\r\n\r\n**Q:** My results are not as good.\r\n**A:** Run the benchmark a few time, it looks like some optimisation kick in later. (Or CPU on energy efficient device migth need to warm up before some optimisations are activated)\r\n\r\n\r\n\r\n## Prior Art\r\n\r\n[Chrome FilePathScore](\r\nhttps://chromium.googlesource.com/chromium/blink/+/master/Source/devtools/front_end/sources/FilePathScoreFunction.js#70)\r\n\r\n[Textmate ranker](https://github.com/textmate/textmate/blob/master/Frameworks/text/src/ranker.cc#L46)\r\n\r\n[VIM Command-T ](https://github.com/wincent/command-t/blob/master/ruby/command-t/match.c#L22)\r\n\r\n[Selecta](https://github.com/garybernhardt/selecta/blob/master/selecta#L415)\r\n\r\n[PeepOpen](https://github.com/topfunky/PeepOpen/blob/master/Classes/Models/FuzzyRecord.rb)\r\n\r\n[flx](https://github.com/lewang/flx)\r\n\r\n\r\n## List of addressed issues\r\n\r\n### Exact match vs directory depth.\r\n\r\nhttps://github.com/atom/fuzzaldrin/issues/18\r\n-> actionsServiceSpec\r\n\r\nhttps://github.com/atom/atom/issues/7783\r\n-> usa_spec\r\n\r\n### Start of string VS directory depth\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/57#issuecomment-133531653\r\n-> notification\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/21#issuecomment-48795958\r\n-> video backbone\r\n\r\n### Folder / file query\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/21#issue-29106280\r\n-> src/app vs destroy_discard\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/21#issuecomment-46920333\r\n-> email handler\r\n\r\nhttps://github.com/substantial/atomfiles/issues/43\r\n-> model user\r\n\r\n### Spread/group vs directory depth\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/21#issuecomment-138664303\r\n-> controller core\r\n\r\n### Initialism\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/57#issue-42120886\r\n-> itc switch / ImportanceTableCtrl\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/57#issuecomment-95623924\r\n-> application controller\r\n\r\nhttps://github.com/atom/fuzzaldrin/issues/21\r\n-> fft vs FilterFactorTests\r\n\r\n### Accidental Acronym\r\n\r\nhttps://github.com/atom/command-palette/issues/28\r\n-> Install / Find Select All\r\n\r\nhttps://github.com/atom/fuzzaldrin/issues/20#issue-93279352\r\n-> Git Plus Stage Hunk / Git Plus Push\r\n\r\n\r\n### Case sensitivity\r\n\r\nhttps://github.com/atom/autocomplete-plus/issues/42\r\n-> downloadThread / DownloadTask\r\n\r\nhttps://github.com/atom/fuzzaldrin/issues/17\r\n-> diagnostics / Diagnostic\r\n\r\n\r\n### Optional Characters\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/91\r\nhttps://github.com/atom/fuzzaldrin/issues/24\r\n\r\n-> PHP Namespaces, let \"\\\" match \"/\"\r\n-> (would be nice for config file in mized OS environment too)\r\n\r\nhttps://github.com/atom/fuzzy-finder/pull/51\r\n\r\n-> Ruby Namespaces, let \"::\" match \"/\"\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/10\r\n-> SpaceRegex, let \" \" match \"/\"\r\n-> was already implemented, posted here to show parallel. \r\n\r\n\r\n### Suggestions\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/21#issue-29106280\r\n-> we implement suggestion of score based on run length\r\n-> todo allow fuzzaldrin to support external knowledge.\r\n\r\n","maintainers":[{"name":"jeancroy","email":"jcking@gmail.com"}],"time":{"modified":"2015-09-24T01:44:35.566Z","created":"2015-09-24T01:44:35.566Z","0.1.0":"2015-09-24T01:44:35.566Z"},"homepage":"https://github.com/jeancroy/fuzzaldrin-plus","keywords":["fuzzy","approximate","string","matching","filter","search","highlight","sublime"],"repository":{"type":"git","url":"https://github.com/jeancroy/fuzzaldrin-plus.git"},"bugs":{"url":"https://github.com/jeancroy/fuzzaldrin-plus/issues"},"readmeFilename":"README.md","_attachments":{},"_etag":"\"65MQZHTS1A3M6HX849VPE7NAK\""}