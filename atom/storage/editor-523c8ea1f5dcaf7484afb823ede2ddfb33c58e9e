{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":23,"width":1680,"height":979,"maximized":true},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"project":{"deserializer":"Project","paths":["/Users/doot/projects"],"buffers":[{"text":"#!/bin/env perl\n\nBEGIN { @INC = (@INC,split(\":\",$ENV{FID_PERL5LIB})) }\n\nuse strict;\nuse warnings; #DEBUG\nuse Data::Dumper;\n\nuse DBI;\nuse Getopt::Std;\nuse List::Util qw/first/;\nuse IO::Handle;\nuse IO::Socket;\nuse Fcntl ':flock'; # import LOCK_* constants\nuse Switch;\nuse Time::HiRes qw/sleep usleep ualarm gettimeofday tv_interval/;\nuse POSIX qw/WNOHANG strftime/;\nuse POSIX \":sys_wait_h\"; # Nonblocking wait\nuse Env qw/CASE FID_CRON_JOB_NAME FID_TRACE_ENABLE L DSQUERY/;\n\npackage main;\n{\nuse strict;\nuse warnings;\n\n## Variables used throughout main package\nmy %opts;\nmy $pDbh;\nmy $saDbh;\nmy $userTempdb;\nmy @conflictingSprocs;\nmy %conflictingCheck;\nmy %details;\nmy %errors;\nmy $exitStatus;\nmy $initStatSql;\nmy @updateStatsTables;\n\n## Limits\nmy $maxSprocs;               # Max number of sprocs we can run at once\nmy $maxPdfs;                 # Max number of PDFs we can run at once\nmy $conflictingSprocThresh;  # Once we get down to this many sprocs left, don't bother checking for conflicts\nmy $iterations        = 0;   # Keep track of how many iterations our loop has gone through\nmy $maxPerformanceDisp;      # Max number of sprocs and PDFs to show in the performance report\n\n## Queues\nmy @sprocQueue        = ();\nmy %sprocRunningQueue = ();\nmy @pdfQueue          = ();\nmy %pdfRunningQueue   = ();\nmy @endQueue          = ();\n\nsub main {\n  init();\n  printReports() if $details{LIST_REPORTS};\n  updateStats();\n  initConflictingSprocs();\n  initSprocOptions();\n  if ( scalar @sprocQueue == 0 ) {\n    l(\"No reports found, exiting\", 2);\n    exit(1);\n  }\n  initPriorityReports(\\@sprocQueue);\n\n  if ( $details{CENTRAL_FALLBACK} ) {\n    l(\"Report generation starting using fallback mode.  Will generate PDFs using the following settings from SystemDefinition.cfg\");\n    l(\"PDF HOST: $details{PDF_GENERATOR_USER}\\@$details{PDF_GENERATOR_HOST}\");\n    l(\"RPT HOST: $details{PDF_RPT_USER}\\@$details{PDF_RPT_HOST}:$details{PDF_RPT_BASE}\");\n    l(\"DST HOST: $details{PDF_DESTINATION_USER}\\@$details{PDF_DESTINATION_HOST}:$details{PDF_DESTINATION_BASE}\");\n    rsyncPdfHost();\n  } else {\n    l(\"Using $details{CENTRAL_DB_DETAILS}{HOSTNAME}:$details{CENTRAL_DB_DETAILS}{DATABASE} to gather report generation PCs\");\n  }\n\n  printReports();\n\n  # Empty the sprocQueue into the pdfQueue when sprocs execution is disabled\n  if (!$details{SPROCS_ENABLED}) {\n    @pdfQueue = @sprocQueue;\n    undef @sprocQueue;\n  }\n\n  $errors{STAGE}  = \"SPROCS\";\n  updateControl();\n\n  $SIG{'INT'}     = 'INT_handler'; # Overwrite handler so we attempt to mark running PDFs complete in an unexpected exit during PDF generation\n  $SIG{'__DIE__'} = 'INT_handler';\n\n\n  ## Main Event Loop\n  ## This will continuously loop throughout the life of the script and spawn off children sprocs and PDF runs as necessary\n  while ( 1 ) {\n    l(\"################### Start of Event Loop Iteration ($iterations) ###################\", 3);\n\n    ####### Fork off sproc runs #######\n    if ( @sprocQueue && scalar keys %sprocRunningQueue < $maxSprocs ) {\n      # We still have sprocs left to run AND we are not currently running more than the limit\n      forkSproc();\n    }\n\n    ####### Reap finished child sprocs #######\n    checkFinishedSprocs();\n\n    # Only set the current stage to PDFS if it is not already set there are no more sprocs running or in the queue\n    if ( $errors{STAGE} ne \"PDFS\" && ( !@sprocQueue && scalar keys %sprocRunningQueue == 0 )) {\n      l(\"All sprocs complete, setting stage to PDFS from $errors{STAGE}\", 0);\n      $errors{STAGE} = \"PDFS\";\n      updateControl();\n      cleanTodaysData() if defined $opts{C};\n    }\n\n    ####### Fork off PDF runs #######\n    if ( @pdfQueue && scalar keys %pdfRunningQueue < $maxPdfs ) {\n      # We still have PDFs left to run AND we are not currently running more than the limit\n      forkPdf();\n    }\n\n    ####### Reap finished child PDF generations #######\n    checkFinishedPdfs();\n\n    ####### Check if Event Loop has finished (if all queues are empty) #######\n    if ( !@sprocQueue && !(scalar keys %sprocRunningQueue) && !@pdfQueue && !(scalar keys %pdfRunningQueue) ) {\n      l(\"#############################################################################\");\n      l(\"########### No more sprocs or PDFs left to run, exiting main loop ###########\");\n      l(\"#############################################################################\");\n      last;\n    }\n    sleep($details{INTERVAL}) if defined $details{INTERVAL};\n    l(\"################### End of Event Loop Iteration ($iterations) ###################\\n\\n\", 3);\n  }\n\n  # Restore handler to default after report generation has completed\n  $SIG{'INT'}     = 'DEFAULT';\n  $SIG{'__DIE__'} = 'DEFAULT';\n\n  if ( $details{INTERACTIVE} == 0 && $exitStatus == 0 ) {\n    l(\"Removing CronJob token\\n\");\n    unlink(\"$CASE/runtime/scripts/control/CronJob.${FID_CRON_JOB_NAME}.control\");\n  }\n\n  printState();\n\n  printPerformance();\n\n  $errors{EXIT} = $exitStatus;\n  updateControl();\n\n  # Clean up\n  destroy();\n\n  return($exitStatus);\n}\n\n\n####### Functions #######\n\nsub init {\n  `/bin/tty -s`;\n  if ( $? != 0 ) {\n    print \"Running from cron or at job.\\n\";\n    $details{INTERACTIVE} = 0;\n  } else {\n    print \"Running from console.\\n\";\n    $details{INTERACTIVE} = 1;\n  }\n\n  # Only run on primary\n  chomp (my $role = `ExecTclProc -notrace Fid_SystemRole`);\n  if ( $role ne 'PRIMARY' ) {\n    print \"Not running on system in $role role\\n\";\n    if ( $details{INTERACTIVE} == 0 ) {\n      print \"Removing CronJob token.\\n\";\n      unlink(\"$CASE/runtime/scripts/control/CronJob.${FID_CRON_JOB_NAME}.control\");\n    }\n    exit(0);\n  }\n\n  # Defaults and static values\n  $userTempdb                         = \"tempdb\"; # Default tempdb to check for conflicting sprocs.\n  $conflictingSprocThresh             = 2;        # Number of remaining sprocs before we stop checking for conflics and just run whatever is left.\n  $maxSprocs                          = 0;        # Max number of sprocs to run in parallel.  If 0 this is set based on the number of engines.\n  $maxPdfs                            = 1;        # Max number of PDFs to run in parallel.  If not specified at the command line this is set to $maxSprocs.\n  $maxPerformanceDisp                 = 10;       # Max number of sprocs and PDFs to show in the performance report.\n  $exitStatus                         = 0;        # Status the script will return with when it exits.\n  $details{PPID}                      = $$;       # Parent PID so children can write to control file.\n  $details{TIMEOUT}                   = 10800;    # Timeout until warning or kill (warn unless -e is supplied) in seconds.  Default 180 minutes.\n  $details{CONTROL}                   = \"$CASE/runtime/scripts/control/ExecReportsV8\";\n  $details{EXT}                       = \"pdf\";    # File extension.\n  $details{INTERVAL}                  = 0.25;     # Number of seconds to sleep in the event loop.  Can be fractions of a second.\n  $details{DEBUG}                     = 0;        # Determines if debug messages should be printed. Default is disalbed (0).\n  $details{LOG_READS}                 = 0;        # Determines if the number of logical reads should be logged. Default is disabled (0).\n  $details{CENTRAL_FALLBACK}          = 0;        # Determines if ExecReports should fall back to using the pdf generator host defined in SysDef instead of from the central table\n  $details{RERUN_MODE}                = 0;        # Determines if ExecReports should run in rerun mode. This is to replicate the behavior of ReRunReports\n  $details{LIST_REPORTS}              = 0;\n  $details{SPROCS_ENABLED}            = 1;        # Running sprocs enabled by default\n  $details{PDFS_ENABLED}              = 1;        # PDF generation enabled by default\n  @updateStatsTables                  = qw/TB_ORDER TB_ORDER_DETAIL TB_CURRENT_ORDER TB_TRADE TB_TRADE_SET TB_ORDER_EXECUTION/;\n\n  # SysDef defaults\n  $details{CENTRAL_PDF_SLEEP}         = 15;\n  $details{CENTRAL_PDF_TIMEOUT_WARN}  = 3600;\n  $details{MAX_PDF_RETRY}             = 3;\n  $details{PDF_RETRY_SLEEP}           = 30;\n\n  if ( -x \"/usr/local/bin/ssh\" ) {\n    $details{SSH} = \"/usr/local/bin/ssh -x -o 'StrictHostKeyChecking=no' -o 'ConnectTimeout=30' -o 'PreferredAuthentications=publickey' -o 'BatchMode=yes'\";\n  } else {\n    $details{SSH} = \"ssh\";\n  }\n\n  # Get command line arguments\n\n  if ( defined $opts{h} ) {\n    printUsage();\n    exit(0);\n  }\n\n  if ( !defined $opts{m} ) {\n    print \"MPID not defined using -m\\n\";\n    printUsage();\n    exit(1);\n  } else {\n    $details{MPID} = $opts{m};\n  }\n\n  if ( !defined $opts{d} ) {\n    print \"Database must be defined with -d\\n\";\n    printUsage();\n    exit(1);\n  } else {\n    $details{DATABASE} = $opts{d};\n  }\n\n  $details{DEBUG}             = 1 if defined $opts{D};\n  $details{LOG_READS}         = 1 if defined $opts{l};\n  $details{CENTRAL_FALLBACK}  = 1 if defined $opts{f};\n  $details{RERUN_MODE}        = 1 if defined $opts{R};\n  $details{INTERACTIVE}       = 1 if $details{RERUN_MODE}; # Force interactive mode (console) if in rerun mode to prevent removing control files\n\n  # Initialize logging\n  open $details{log}, \">/dev/stdout\";\n  $details{log}->autoflush(1);\n\n  # ReRun mode specific command line options\n  if ($details{RERUN_MODE}) {\n    # List reports and exit\n    $details{LIST_REPORTS} = 1 if defined $opts{a};\n\n    # Activity date to rebuild database to\n    if (defined $opts{b}) {\n      if ($opts{b} =~ /^20[0-9]{2}[01][0-9][0-3][0-9]$/) {\n        $details{REBUILD_DATE} = $opts{b};\n      } else {\n        print \"Date not in valid format YYYYMMDD: $opts{b}\\n\";\n        exit(1);\n      }\n    }\n\n    $details{SPROCS_ENABLED} = 0 if defined $opts{g}; # Disable sprocs if -g is supplied (run only PDF generation)\n    $details{PDFS_ENABLED}   = 0 if defined $opts{s}; # Disable PDF generation if -s is supplied (run only sprocs)\n    if (!$details{SPROCS_ENABLED} && !$details{PDFS_ENABLED}) {\n      print \"Either PDF generation or sproc execution (or both) must be enabled.  No point in executing without one or the other\\n\";\n      exit(1);\n    }\n    l(\"Sproc execution disabled\") if !$details{SPROCS_ENABLED};\n    l(\"PDF generation disabled\")  if !$details{PDFS_ENABLED};\n\n    if (!$details{LIST_REPORTS}) {\n      # Alternate log file location\n      if (defined $opts{L}) {\n        $details{LOG_FILE} = $opts{L};\n      } else {\n        my $dateString = strftime \"%Y%m%d_%H:%M:%S\", localtime;\n        my $dateArg = ( $details{REBUILD_DATE} ? \"_$details{REBUILD_DATE}_\" : \"_\" );\n        $details{LOG_FILE} = \"$L/RERUN_REPORTS_$opts{m}$dateArg$dateString\";\n      }\n      l(\"Logging to the file $details{LOG_FILE}\");\n      open $details{rerun_log}, \">$details{LOG_FILE}\" or die \"Could not open $details{LOG_FILE} $!\";\n\n      l(\"Running in ReRun mode.\");\n    }\n\n    if (defined $opts{y}) {\n      $details{RERUN_REPORT_LIST} = [split(\" \", $opts{y})];\n      foreach my $report (@{$details{RERUN_REPORT_LIST}}) {\n        $report = uc($report);\n      }\n    }\n  } else {\n    # If not in rerun mode, complain if any rerun specific command line arguments were provided\n    if (defined $opts{a} || defined $opts{o} || defined $opts{L} ||\n        defined $opts{b} || defined $opts{s} || defined $opts{g} || defined $opts{y}) {\n      l(\"A rerun specific command line option was provided.  Please only use rerun specific arguments when explicitly in rerun mode via -R\", 1);\n      exit(1);\n    }\n  }\n\n  if ( !defined $opts{t} ) {\n    l(\"Type not defined using -t, using default of 'D'\\n\");\n    $opts{t} = 'D';\n  }\n  if ( $opts{t} ne 'D' && $opts{t} ne 'M' ) {\n    print \"Type must be either 'D' for daily or 'M' for monthly\\n\";\n    printUsage();\n    exit(1);\n  } else {\n    $details{TYPE} = $opts{t};\n  }\n\n  if (!defined $opts{S}) {\n    l(\"Server name not supplied with -S.  Attempting to use value from environment variable \\$DSQUERY: $DSQUERY\");\n    $opts{S} = $DSQUERY;\n  }\n\n  if ((!defined $opts{U} && !defined $opts{P}) && $opts{S} =~ /RPT.$/) {\n    l(\"Username and password not supplied with -U and -P. Attempting to login with lower case database name as this appears to be an RPT server\");\n    $opts{P} = lc($details{DATABASE});\n    $opts{U} = lc($details{DATABASE});\n  }\n\n  if ( defined $opts{S} && defined $opts{U} && defined $opts{P} ) {\n    $details{ASE_NAME} = $opts{S};\n    $details{USERNAME} = $opts{U};\n    $details{PASSWORD} = $opts{P};\n  } else {\n    l(\"Attempting to set Sybase details automatically\");\n    my $loginDetails   = getDbLoginDetails(\"R\", undef, $details{DATABASE});\n    $details{HOSTNAME} = $loginDetails->{HOSTNAME};\n    $details{ASE_NAME} = $loginDetails->{ASE_NAME};\n    $details{USERNAME} = $loginDetails->{USERNAME};\n    $details{PASSWORD} = $loginDetails->{PASSWORD};\n  }\n\n  # Get all values for SysDef items defined in @sysDefItems\n  my @sysDefItems = qw/PDF_GENERATOR_USER PDF_GENERATOR_HOST PDF_DESTINATION_USER PDF_DESTINATION_HOST PDF_DESTINATION_BASE PDF_RPT_USER PDF_RPT_HOST PDF_RPT_BASE PDF_GENERATOR_HOST_LIST SYB_PRIMARY_HOST CENTRAL_PDF_SLEEP CENTRAL_PDF_TIMEOUT_WARN MAX_PDF_RETRY PDF_RETRY_SLEEP/;\n  push @sysDefItems, \"PRIORITY_REPORT_LIST_$details{MPID}\";\n  for my $item (@sysDefItems) {\n    my $value = `ExecTclProc -notrace Fid_ServerAttr $item`;\n    chomp ($value);\n    if ( $value eq \"\" && defined $details{$item} ) {\n      l(\"Could not find $item, using default of $details{$item}\");\n    } elsif ( $value eq \"\" && !defined $details{$item} ) {\n      l(\"Could not find $item and there is no default available\", 1);\n    } else {\n      $details{$item} = $value;\n      l(\"Setting SysDef item $item to $value\");\n    }\n  }\n\n  # Do any extra processing needed for specific SysDef values\n  if ( defined $details{\"PRIORITY_REPORT_LIST_$details{MPID}\"} ) {\n    $details{PRIORITY_REPORT_LIST} = [split(\" \", $details{\"PRIORITY_REPORT_LIST_$details{MPID}\"})];\n  }\n  if ( defined $details{PDF_GENERATOR_HOST_LIST} ) {\n    my @hostList = split(\" \", $details{PDF_GENERATOR_HOST_LIST});\n    $details{PDF_GENERATOR_HOST} = $hostList[int(rand(@hostList))];\n    l(\"PDF_GENERATOR_HOST_LIST found, setting PDF_GENERATOR_HOST to a random element of this list: $details{PDF_GENERATOR_HOST}\");\n  }\n\n  if ( $details{RERUN_MODE} ) {\n    if (defined $opts{o}) {\n      $details{PDF_DESTINATION_BASE} = $opts{o};\n    } else {\n      l(\"ReRun mode enabled and destination directory not specified using '-o' flag.  Using default of '/ext1/clients'.\");\n      $details{PDF_DESTINATION_BASE} = '/ext1/clients';\n    }\n    l(\"Setting SysDef item PDF_DESTINATION_BASE to $details{PDF_DESTINATION_BASE} due to ReRun mode\");\n  }\n\n  l(\"Enforcing timeout of $details{TIMEOUT} seconds\") if defined $opts{e};\n\n  l(\"Connecting to $details{USERNAME}\\@$details{ASE_NAME}..$details{DATABASE}\");\n  $details{CENTRAL_DB_DETAILS} = getDbLoginDetails(\"R\", $details{SYB_PRIMARY_HOST}, \"STATS_DB\");\n  $details{util} = new Util( \\%details );\n  $pDbh = $details{util}->newDbh();\n\n  # Confirm we are running in the correct database\n  my $sth = $pDbh->prepare(\"select db_name()\");\n  $sth->execute();\n  my $dbname = $sth->fetchrow_array();\n  $sth->finish();\n  if ( $dbname ne $details{DATABASE} ) {\n    l(\"$dbname does not match $details{DATABASE}\", 2);\n    exit(1);\n  }\n\n  l(\"Connecting as 'sa' user to update statistics and to check sysprocesses for concurrently running sprocs\");\n  $details{SA_DETAILS}  = getDbLoginDetails(\"F\");\n  $saDbh                = $details{util}->newDbh($details{SA_DETAILS}->{USERNAME}, $details{SA_DETAILS}->{PASSWORD});\n\n  $maxSprocs = $opts{p} if defined $opts{p};\n\n  # Set $maxSprocs to the number of engines if no value is supplied\n  if ( $maxSprocs == 0 ) {\n    my $sth = $pDbh->prepare(\"select count(*) from master..sysengines where status='online'\");\n    $sth->execute();\n    my $engines = $sth->fetchrow_array();\n    $sth->finish();\n    $maxSprocs = $engines + 1;\n  }\n\n  if ( !defined $opts{r} ) {\n    $maxPdfs = $maxSprocs;\n  } else {\n    $maxPdfs = $opts{r};\n  }\n\n  # Ensure both $maxSprocs and $maxPdfs have a value other than zero\n  $maxSprocs = 1 if $maxSprocs == 0;\n  $maxPdfs   = 1 if $maxPdfs   == 0;\n\n  l(\"Parallelism set to: \\n\\tSprocs: $maxSprocs \\n\\tPDFs  : $maxPdfs\");\n\n  rebuildRepData() if defined $details{REBUILD_DATE} && !$details{LIST_REPORTS};\n\n  # Get activity date\n  $sth = $pDbh->prepare(\"select convert(char(8), Activity_Date_Trade) as ACTIVITY_DATE from VW_ACTIVITY_DATE\");\n  $sth->execute();\n  my $activityDate = $sth->fetchrow_hashref();\n  $sth->finish();\n  if ( !defined $activityDate->{ACTIVITY_DATE} || $activityDate->{ACTIVITY_DATE} eq \"\" ) {\n    l(\"Could not determine ACTIVITY_DATE\", 1);\n  } else {\n    $details{ACTIVITY_DATE} = $activityDate->{ACTIVITY_DATE};\n    l(\"Activity Date is $details{ACTIVITY_DATE}\");\n    if ( defined $opts{A} ) {\n      $details{EXT} = \"$details{ACTIVITY_DATE}.$details{EXT}\";\n    }\n  }\n\n  $initStatSql = \"\n    if exists (\n      select 1 from STATS_DB..REPORT_STATISTICS where ACTIVITY_DATE = ? and CLIENT_CODE = ? and PDF_NAME = ? and SPROC_NAME = ?\n    )\n    begin\n      update\n        STATS_DB..REPORT_STATISTICS\n      set\n        PDF_START_DT    = NULL,\n        PDF_END_DT      = NULL,\n        PDF_RUN_TIME    = NULL,\n        SPROC_START_DT  = NULL,\n        SPROC_END_DT    = NULL,\n        SPROC_RUN_TIME  = NULL,\n        RUN_COUNT       = (RUN_COUNT + 1)\n      where\n        ACTIVITY_DATE   = ?\n        and CLIENT_CODE = ?\n        and PDF_NAME    = ?\n        and SPROC_NAME  = ?\n    end\n    else\n    begin\n      insert into STATS_DB..REPORT_STATISTICS\n        (ACTIVITY_DATE,CLIENT_CODE,PDF_NAME,SPROC_NAME)\n      values\n        (?, ?, ?, ?)\n    end\n  \";\n\n  @sprocQueue = getReportList();\n}\n\nsub printReports {\n  my $reportListStr;\n  for my $r (@sprocQueue) {\n    $reportListStr = $reportListStr . \"\\n\\t$r->{reportName} ($r->{sprocName}, $r->{pdfFileName}, $r->{cacheName})\";\n  }\n  l(\"Report List:$reportListStr\");\n\n  l(\"Report list printed, exiting\") if $details{LIST_REPORTS};\n  exit(0) if $details{LIST_REPORTS};\n}\n\nsub rebuildRepData {\n  l(\"Rebuilding Report Data to $details{REBUILD_DATE}\");\n  my $sth = $pDbh->prepare(\"exec rSP_ASP_rebuild_rep_data ?, ?\");\n  $sth->{syb_do_proc_status} = 1;\n  $sth->execute($details{REBUILD_DATE}, 'A');\n  $sth->fetch(); # Ignore output since we only care about return code\n  my $retVal = $sth->{syb_proc_status};\n  $sth->finish();\n\n  if ($retVal != 0) {\n    l(\"Could not rebuild_rep_data to $details{REBUILD_DATE}\", 2);\n    exit(1);\n  } else {\n    $pDbh->do(\"update iTB_system_definition set VALUE = ? where ITEM = 'USTP_ACTIVITY_DATE'\", undef, $details{REBUILD_DATE});\n  }\n}\n\nsub initPriorityReports {\n  # Expects array ref which will be modified with priority reports from the SysDef\n  my ($reports) = @_;\n\n  if ( !$details{PRIORITY_REPORT_LIST} ) {\n    l(\"There were no reports specified in the priority report list\");\n  } else {\n    l(\"The following reports will be run first, if they are enabled, due to the priority report list: \" .\n    \"\\n\\t\" . join(\"\\n\\t\", @{ $details{PRIORITY_REPORT_LIST} }) );\n\n    my @priorityReports;\n    for my $p (@{ $details{PRIORITY_REPORT_LIST} }) {\n      my $i = first { @$reports[$_]->{reportName} eq $p } 0..$#$reports;\n      my ($pos) = grep { @$reports[$_]->{reportName} eq $p } 0..$#$reports;\n      push(@priorityReports, splice(@$reports, $pos, 1)) if defined $pos;\n    }\n    unshift(@$reports, @priorityReports);\n\n    my $priorityReportString = \"\";\n    for my $r (@priorityReports) {\n      $priorityReportString .= \"\\n\\t$r->{reportName}\";\n    }\n    l(\"These priority reports were found:$priorityReportString\");\n  }\n}\n\nsub cleanTodaysData {\n  l(\"Running clean_todays_data sproc\");\n  my $retVal;\n\n  my $sth = $pDbh->prepare(\"exec clean_todays_data\");\n  $sth->execute();\n  do {\n    my $rt = $sth->{syb_result_type};\n    while ( my $ref = $sth->fetchrow_hashref() ) {\n      if ( $rt == 4043 ) {\n        $retVal = $$ref{\"COL(1)\"};\n      } else {\n        foreach my $field ( keys %{$ref} ) {\n          l(\"Type $rt: $field: $$ref{$field}\");\n        }\n      }\n    }\n  } while ( $sth->{syb_more_results} );\n  $sth->finish();\n\n  if ( $retVal  == 0 ) {\n    l(\"clean_todays_data returned $retVal\", 0);\n  } else {\n    l(\"clean_todays_data returned $retVal\", 1);\n    $exitStatus = 1;\n  }\n}\n\nsub rsyncPdfHost {\n  # Sync .rpt files, hosts file and sql.ini file.  Should only be called if running on a single PDF host (fallback mode).\n  my $cmd;\n  my $rsyncBaseCmd = \"$details{SSH} $details{PDF_GENERATOR_USER}\\@$details{PDF_GENERATOR_HOST} 'rsync -azv --force --rsh=ssh $details{PDF_RPT_USER}\\@$details{PDF_RPT_HOST}\";\n\n  l(\"Beginning /etc/hosts sync\");\n  open($cmd, \"$rsyncBaseCmd:/etc/hosts /cygdrive/c/WINDOWS/system32/drivers/etc/hosts'|\");\n  while ( <$cmd> ) {\n    chomp;\n    l(\"SSH: $_\");\n  }\n  close($cmd);\n  if ( $? > 0 ) {\n    $errors{PDFPREP} = \"Could Not Sync /etc/hosts\";\n    updateControl();\n    l(\"Could not sync /etc/hosts\", 2);\n    $exitStatus = 2;\n  }\n\n  l(\"Beginning sql.ini sync\");\n  open($cmd, \"$rsyncBaseCmd:$details{PDF_RPT_BASE}/sql.ini /cygdrive/c/Sybase/ini'|\");\n  while ( <$cmd> ) {\n    chomp;\n    l(\"SSH: $_\");\n  }\n  close($cmd);\n  if ( $? > 0 ) {\n    $errors{PDFPREP} = \"Could Not Sync sql.ini\";\n    updateControl();\n    l(\"Could not sync sql.ini\", 2);\n    $exitStatus = 2;\n  }\n\n  l(\"Beginning RPT sync\");\n  open($cmd, \"$rsyncBaseCmd:$details{PDF_RPT_BASE}/$details{MPID} /Rpt'|\");\n  while ( <$cmd> ) {\n    chomp;\n    l(\"SSH: $_\");\n  }\n  close($cmd);\n  if ( $? > 0 ) {\n    $errors{PDFPREP} = \"Could Not Sync RPTs\";\n    updateControl();\n    l(\"Could not sync RPTs\", 2);\n    $exitStatus = 2;\n  }\n}\n\n# Handler to run if process is killed.  This will attempt to mark any currently running PDFs as completed in the central table\nsub INT_handler {\n  l(\"Dumping current state of report run\", 1);\n  warn \"Dumping current state of report run\\n\";\n  printState(4);\n  l(\"$$ Improper exit. Last attempt to see if we can mark any currently running PDFs as completed.\", 1);\n  warn \"$$ Improper exit. Last attempt to see if we can mark any currently running PDFs as completed.\\n\";\n\n  my $cdbh = $details{util}->newCentralDBH();\n  if ( $cdbh ) {\n    my $sql = \"\n      exec sp_fidessa_end_pdf\n        \\@serverName = ?,\n        \\@databaseName = ?\n        \\@activityDate = ?\";\n\n    my @args = ($details{ASE_NAME}, $details{DATABASE}, $details{ACTIVITY_DATE});\n    my %options = ( 'arglist' => \\@args, );\n    my @result = $cdbh->syb_nsql($sql, \"HASH\", \\%options);\n\n    $cdbh->commit();\n    $cdbh->disconnect();\n    print Dumper(@result);\n  } else {\n    # We can't really do anything at this point if it still fails to mark PDFs as completed, so just log it and hope for the best\n    l(\"$$ Improper exit.  Last attempt to mark currently running PDFs complete was NOT successful.  Please check to see if manual action is needed in the database.\", 2);\n    warn \"$$ Improper exit.  Last attempt to mark currently running PDFs complete was NOT successful.  Please check to see if manual action is needed in the database.\";\n    $errors{ENDPDF} = \"There was a failure attempting to mark PDFs completed on an improper exit.  Please check.\";\n    updateControl();\n  }\n\n  if ( $details{RERUN_MODE} ) {\n    for my $report ( @sprocQueue ) {\n      $report->updateReportRuns(\"D\");\n    }\n\n    foreach my $report ( values %sprocRunningQueue ) {\n      $report->updateReportRuns(\"D\");\n    }\n\n    for my $report ( @pdfQueue ) {\n      $report->updateReportRuns(\"D\");\n    }\n\n    foreach my $report ( values %pdfRunningQueue ) {\n      $report->updateReportRuns(\"D\");\n    }\n\n    for my $report ( @endQueue ) {\n      $report->updateReportRuns(\"D\");\n    }\n  }\n\n  main::destroy();\n  exit(1);\n}\n\nsub getDbLoginDetails {\n  my ($loginType, $hostname, $database) = @_;\n  $hostname           = $hostname || `uname -n`;\n  chomp($hostname);\n  my $databaseString;\n  if ( defined $database ) {\n    $databaseString  = \" -d $database\";\n  } else {\n    $databaseString = \"\";\n  }\n\n  my $details = `FidRun sybmon_LoginDetails -h $hostname -t $loginType $databaseString`;\n  if ( $? != 0 ) {\n    l(\"Failed to get details for $hostname with login type $loginType via sybmon_LoginDetails: $details\", 1);\n    exit(1);\n  }\n  chomp $details;\n\n  my %returnDetails;\n  my @detailsArray         = split (/\\|/, $details);\n  $returnDetails{HOSTNAME} = $detailsArray[0];\n  $returnDetails{ASE_NAME} = $detailsArray[1];\n  $returnDetails{USERNAME} = $detailsArray[2];\n  $returnDetails{PASSWORD} = $detailsArray[3];\n  $returnDetails{DATABASE} = $database;\n  return \\%returnDetails;\n}\n\nsub printUsage {\n  print \"ExecReports_V8.pl\\n\\n\";\n  print \"Usage: $0 <args>\\n\";\n  print \"\\t-m <string> (required) MPID which must meet the GenPdf requirements\\n\";\n  print \"\\t  for RPT and Dest Directory\\n\";\n  print \"\\t-d <string>   (required) Database name\\n\";\n  print \"\\t-S <string>   (optional) Sybase server name\\n\";\n  print \"\\t-U <string>   (optional) Sybase username\\n\";\n  print \"\\t-P <string>   (optional) Sybase password\\n\";\n  print \"\\t-t <char>     (optional) Right now only 'D' for Daily is supported\\n\";\n  print \"\\t-p <number>   (optional) Degree of parallelism otherwise calculated as online engines + 1\\n\";\n  print \"\\t-r <number>   (optional) Degree of PDF parallelism otherwise calculated as = to -p\\n\";\n  print \"\\t-e (optional) determines if the timeout is enforced and that report is killed\\n\";\n  print \"\\t-A (optional) ACTIVITY_DATE should be provided in the name of the PDF\\n\";\n  print \"\\t-C (optional) run clean_todays_data sproc at the end of the report run\\n\";\n  print \"\\t-f (optional) falls back to using PDF_GENERATOR_HOST from SystemDefinition.cfg for \\n\";\n  print \"\\t              PDF generation instead of spreading generation over multiple hosts from a central table\\n\";\n  print \"\\t-l (optional) Enables logging the number of logical reads each stored procedure performs\\n\";\n  print \"\\t-D (optional) Enables debugging mode\\n\";\n  print \"\\t              This will output a LOT of debug messages to the log and is intended for troubleshooting\\n\";\n  print \"\\t              it is not meant to be enabled for normal production use\\n\";\n  print \"\\t-R (optional) Runs the script in ReRun mode.  Functionality is similar to ReRunReports.pl script\\n\";\n  print \"\\t              Additional arguments are used in this mode, detailed below\\n\";\n  print \"\\t-h            Print this help message\\n\";\n  print \"\\t**** The following arguments are only valid when script is run in ReRun mode ****\\n\";\n  print \"\\t-o (optional) Destination directory on PDF_DESTINATION_HOST. Defaults to /ext1/clients\\n\";\n  print \"\\t-a (optional) Print the list of active reports and exit\\n\";\n  print \"\\t-L (optional) Log file, default $L/RERUN_REPORTS_MPID_DATE_TIME\\n\";\n  print \"\\t-b <string>   (optional) Date (YYYYMMDD) a rebuild_rep_data should be done for\\n\";\n  print \"\\t-s (optional) Execute ONLY stored procedures, otherwise both stored procedures and PDF generations are run\\n\";\n  print \"\\t-g (optional) Execute ONLY PDF generation, otherwise both stored procedures and PDF generations are run\\n\";\n  print \"\\t-y '<string> <string> <string>...' (optional) list of reports to be run\\n\";\n}\n\nsub updateControl {\n  my ($childStage, $childError) = @_;\n\n  return if $details{RERUN_MODE}; # Don't bother with control files in rerun mode\n\n  my %tmpErr = %errors;\n  if ( defined $childStage && defined $childError ) {\n    # If we are calling from a child process write to a separate child control file. When a child exits it will call cleanUpChildControl with it's PID.\n    # If the child control file exists its ENDPDF errors will be written to the parent at that time and the child control file removed.\n    # This way warnings show up for child pids while they can't contact whk1 and are cleared when the child eventually finishes.\n    # This also prevents children from overwriting the parent control file.\n\n    my $childTempFile = \"$details{CONTROL}.$details{MPID}-child-.$$.control\";\n    l(\"Printing to child control file: $childTempFile\", 3);\n    open my $childCon, \">$childTempFile\" or die \"Could not open control $!\";\n    $childCon->autoflush(1);\n    print $childCon \"$childStage|$childError\\n\";\n    close($childCon);\n  } else {\n    my $tempFile = \"$details{CONTROL}.$details{MPID}.$details{PPID}.control.temp\";\n    l(\"Printing to control file: $tempFile\", 3);\n    open my $con, \">$tempFile\" or die \"Could not open control $!\";\n    $con->autoflush(1);\n    foreach my $key (keys %tmpErr){\n      print $con \"$key|$tmpErr{$key}\\n\";\n    }\n    close($con);\n    rename $tempFile, \"$details{CONTROL}.$details{MPID}.$details{PPID}.control\";\n  }\n}\n\nsub cleanUpChildControl {\n  # Called after a child exits.\n  # Gathers any errors we want to keep from the child control file, writes them to the parent control file and then removes the child control file.\n  my ($childPid) = @_;\n  my $childTempFile = \"$details{CONTROL}.$details{MPID}-child-.$childPid.control\";\n\n  return if $details{RERUN_MODE};  # Don't bother with control files in rerun mode\n  return if (! -e $childTempFile); # Make sure child control file exists\n\n  l(\"Reading child control file: $childTempFile\", 3);\n\n  open my $childCon, \"<$childTempFile\" or l(\"Could not open child control file: $!\", 1), return; # Note comma operator, attempts print and then returns from sub.  A child control file might not exist if there were no errors..\n  my @lines = <$childCon>;\n  close $childCon;\n\n  for my $line (@lines) {\n    chomp($line);\n    my @s = split /\\|/, $line;\n    if ( $s[0] eq \"ENDPDF\" ) {\n      l(\"Found 'ENDPDF' error, updating main control file\", 3);\n      $errors{ENDPDF} = $s[1];\n    }\n  }\n  updateControl();\n  unlink($childTempFile);\n}\n\nsub l {\n  my ($eventMsg, $eventLevel) = @_;\n  $eventLevel = $eventLevel || 0;\n  my $datestring = strftime \"%Y%m%d %H:%M:%S\", localtime;\n  my $eventLevelDesc;\n\n  switch ( $eventLevel ) {\n    case 0 { $eventLevelDesc = \"STATUS\"; }\n    case 1 { $eventLevelDesc = \"ERROR_\"; }\n    case 2 { $eventLevelDesc = \"PANIC_\"; }\n    case 3 { $eventLevelDesc = \"DEBUG_\"; }\n    case 4 { $eventLevelDesc = \"WARN__\"; }\n  }\n\n  flock ($details{log}, LOCK_EX);\n  flock ($details{rerun_log}, LOCK_EX) if defined $details{rerun_log};\n\n  # Only print debug messages if debugging is enabled\n  if ( ($eventLevel != 3 && $eventLevel != 4) || ($eventLevel == 3 && $details{DEBUG}) ) {\n    print {$details{log}} \"$datestring $eventLevelDesc: $eventMsg\\n\";\n    print {$details{rerun_log}} \"$datestring $eventLevelDesc: $eventMsg\\n\" if defined $details{rerun_log};\n  }\n  if ( $eventLevel == 4 ) {\n    warn \"$datestring $eventLevelDesc: $eventMsg\\n\";\n    print {$details{rerun_log}} \"$datestring $eventLevelDesc: $eventMsg\\n\" if defined $details{rerun_log};\n  }\n\n  flock($details{log}, LOCK_UN);\n  flock($details{rerun_log}, LOCK_UN) if defined $details{rerun_log};\n}\n\nsub destroy {\n  $pDbh->disconnect();\n  $saDbh->disconnect();\n  close $details{rerun_log} if defined $details{rerun_log};\n  close $details{log};\n}\n\nsub reportConflicts {\n  # reportConflicts determines if a given $sprocName conflicts with any other currently running sproc that is using our current tempdb.\n  # Returns the name of the conflicting sproc or sprocs (if there are multiple) or 0 if nothing conflicts.\n  # If the sproc does not exist in the cache it will not check sysprocesses.\n  # Cache is only pulled from STATS_DB in the central server at the start of the report run\n  my ($sprocName) = @_;\n\n  if ( !grep {$_ eq $sprocName} @conflictingSprocs ) {\n    l(\"$sprocName does not exist in \\@conflictingSprocs cache so we don't need to check $userTempdb.\", 3);\n    return 0;\n  } else {\n    l(\"$sprocName exists in \\@conflictingSprocs cache so we are checking to see if conflicts are running in $userTempdb.\");\n  }\n\n  my $conflictSprocSql = \"\n    select\n      object_name(id, dbid) as 'SPROC_NAME',\n      tempdb_id(spid) as 'TEMPDB_ID',\n      db_name(tempdb_id(spid)) as 'TEMPDB_NAME'\n    from\n      master..sysprocesses\n    where\n      db_name(tempdb_id(spid)) = ?\n      and object_name(id, dbid) in (\n      \". join(\",\", map { $saDbh->quote($_) } @{ $conflictingCheck{$sprocName} } ) . \"\n      )\n  \";\n\n  my @result = $saDbh->syb_nsql($conflictSprocSql, \"HASH\", { 'arglist' => [$userTempdb] });\n\n  if ( scalar @result ) {\n    my $conflictSprocs;\n    for my $sproc ( @result ) {\n      $conflictSprocs .= \"$sproc->{SPROC_NAME} \";\n    }\n    return $conflictSprocs;\n  } else {\n    return 0;\n  }\n}\n\nsub forkSproc {\n  my $remainingSprocs = scalar @sprocQueue;\n  l(\"Sprocs left to run: \" . scalar $remainingSprocs);\n  my $sproc = shift @sprocQueue;\n\n  # Check if report is conflicting (or we are down to a low number of sprocs left to run). If so, put it back on the sprocQueue and try to grab another\n  # Also checks to see if the sproc has already been run (in which case we continue) or if it is already running for a different report (WAITING status)\n  if ( (scalar @sprocQueue > $conflictingSprocThresh && $sproc->{sprocStatus} ne \"COMPLETE\") || $sproc->{sprocStatus} eq \"WAITING\" ) {\n    while ( (my $conflictSprocs = reportConflicts($sproc->{sprocName}) || $sproc->{sprocStatus} eq \"WAITING\") && $remainingSprocs > 0 ) {\n      if ( $sproc->{sprocStatus} eq \"WAITING\" ) {\n        l(\"The sproc $sproc->{sprocName} ($sproc->{reportName}) is currently being run by another report\");\n      } else {\n        l(\"The sproc $sproc->{sprocName} ($sproc->{reportName}) conflicts with currently running sprocs: $conflictSprocs\");\n      }\n\n      my $newSproc;\n      if ( grep {$_ eq $sproc->{reportName}} @{$details{PRIORITY_REPORT_LIST}} ) {\n        l(\"Report is a priority, shifting to the front of the queue and attempting to grab another sproc\");\n\n        # Find the next non-conflicting report instead of just the next report in the queue.\n        my $pos = 0;\n        l(\"Finding next non-conflicting report that is not in a 'WAITING' state.\", 3);\n        for my $s ( @sprocQueue ) {\n          if ( !reportConflicts($s->{sprocName}) && $s->{sprocStatus} ne \"WAITING\" ) {\n            l(\"Found non-conflicting report: $sprocQueue[$pos]->{sprocName} ($s->{sprocStatus})\", 3);\n            last;\n          }\n          $pos++;\n        }\n        $newSproc = splice(@sprocQueue, $pos, 1) if defined $pos;\n        unshift @sprocQueue, $sproc;\n      } else {\n        l(\"Pushing $sproc->{sprocName} ($sproc->{reportName}) to the back of the queue and attempting to grab another sproc\");\n        push @sprocQueue, $sproc;\n        $newSproc = shift @sprocQueue;\n      }\n      $sproc = $newSproc;\n      $remainingSprocs--;\n    }\n    if ( $remainingSprocs <= 0 && $sproc->{sprocStatus} ne \"WAITING\" ) {\n      l(\"Could not find any remaining non-conflicting sprocs.  No choice but to run the first conflicting sproc anyway.\");\n    } elsif ( $sproc->{sprocStatus} eq \"WAITING\" ) {\n      l(\"Could not find any remaining non-conflicting sprocs.  $sproc->{sprocName} is currently being run by another report.  Sleeping...\");\n        push @sprocQueue, $sproc;\n        sleep($details{CENTRAL_PDF_SLEEP});\n        return 1;\n    }\n  }\n\n  l(\"The status for sproc $sproc->{sprocName} ($sproc->{reportName}) is $sproc->{sprocStatus}\", 3);\n\n  if ( $sproc->{sprocStatus} eq \"PENDING\" ) {\n    $sproc->{sprocStatus} = \"RUNNING\";\n    foreach my $report (@sprocQueue) {\n      if ( $report->{sprocName} eq $sproc->{sprocName} ) {\n        l(\"Updating sproc status of $report->{sprocName} for $report->{reportName} to 'WAITING' since it will be run by $sproc->{reportName}\");\n        $report->{sprocStatus} = \"WAITING\";\n      }\n    }\n  }\n\n  $sproc->{reportStats}{sprocStart} = time;\n\n  l(\"Running sproc: $sproc->{sprocName} ($sproc->{reportName})\");\n  my $pid;\n  if ( defined($pid = fork()) ) {\n    if ( $pid ) {\n      l(\"Forked child ($pid) for sproc $sproc->{sprocName}\");\n      $sprocRunningQueue{$pid} = $sproc;\n      $sproc->updateReportRuns(\"I\") if $details{RERUN_MODE}; # Increment number of report runs on Sybase page\n    } else {\n      $SIG{'INT'}     = 'DEFAULT'; # Reset signal handlers inside of child so that they are only called once\n      $SIG{'__DIE__'} = 'DEFAULT';\n      my $retCode     = $sproc->runSproc();\n      exit($retCode);\n    }\n  } else {\n    l(\"Error: failed to fork sproc: $sproc->{sprocName}\");\n    exit 1;\n  }\n}\n\nsub forkPdf {\n  l(\"PDFs left to run: \" . scalar @pdfQueue );\n  my $pdf = shift @pdfQueue;\n\n  l(\"Running PDF: $pdf->{reportName}\");\n  my $pid;\n  $pdf->{reportStats}{pdfStart} = time;\n  if ( defined($pid = fork()) ) {\n    if ( $pid ) {\n      l(\"Forked child ($pid) for PDF $pdf->{reportName}\");\n      $pdfRunningQueue{$pid} = $pdf;\n    } else {\n      $SIG{'INT'}     = 'DEFAULT'; # Reset signal handlers inside of child so that they are only called once\n      $SIG{'__DIE__'} = 'DEFAULT';\n      my $retCode     = $pdf->runPdf();\n      exit($retCode);\n    }\n  } else {\n    l(\"Error: failed to fork PDF: $pdf->{reportName}\");\n    exit 1;\n  }\n}\n\nsub checkFinishedSprocs {\n  foreach my $pid (keys %sprocRunningQueue) {\n    my $sproc = $sprocRunningQueue{$pid};\n    my $p = waitpid($pid, WNOHANG);\n    if ( $p == $pid || $p == -1 ) {\n      my $status = $?;\n      my $finishedSproc = delete ($sprocRunningQueue{$pid});\n      $sproc->writeSprocStats($status);\n      $sproc->updateReportRuns(\"D\") if $details{RERUN_MODE}; # Decrement number of running reports on Sybase page\n\n      # Mark any Report objects with the same sproc as complete so we don't rerun the sproc\n      foreach my $report (@sprocQueue) {\n        if ( $report->{sprocName} eq $sproc->{sprocName} && $report->{sprocStatus} ne \"COMPLETE\" ) {\n          l(\"Marking sproc $report->{sprocName} for $report->{reportName} complete since it was just run by $sproc->{reportName}\");\n          $report->{sprocStatus} = \"COMPLETE\";\n        }\n      }\n\n      # Deal with failed sprocs\n      if ( $status != 0 ) {\n        if ( !defined $errors{SPROC} ) {\n          $errors{SPROC} = $sproc->{sprocName};\n        } else {\n          $errors{SPROC} .= \" $sproc->{sprocName}\";\n        }\n        updateControl();\n        $exitStatus = 1;\n      }\n\n      l(\"Removed sproc $sproc->{sprocName} ($pid) from the sprocRunningQueue. Child return status: $status. Duration: $sproc->{reportStats}{sprocDur}.\");\n      if ($details{PDFS_ENABLED}) {\n        push @pdfQueue, $sproc;\n        l(\"Added $sproc->{reportName} to pdfQueue\");\n      } else {\n        l(\"PDF generation disabled. Added $sproc->{reportName} directly to endQueue\");\n        push @endQueue, $sproc;\n      }\n    } else {\n      l(\"Sproc $sproc->{sprocName} ($pid, $p) is still running.\", 3);\n      if ( $sproc->checkSprocTimeout($details{TIMEOUT}) ) {\n        if ( !defined $errors{TIMEOUT} ) {\n          $errors{TIMEOUT} = $sproc->{sprocName};\n        } else {\n          $errors{TIMEOUT} .= \" $sproc->{sprocName}\";\n        }\n        updateControl();\n        l(\"$$ sproc $sproc->{sprocName} timed out after $details{TIMEOUT} seconds\", 1);\n        if ( defined $opts{e} ) {\n          l(\"$$ Killing pid $pid\", 1);\n          kill('INT', $pid);\n        }\n      }\n    }\n  }\n}\n\nsub checkFinishedPdfs {\n  foreach my $pid (keys %pdfRunningQueue) {\n    my $pdf = $pdfRunningQueue{$pid};\n    my $p = waitpid($pid, WNOHANG);\n    if ( $p == $pid || $p == -1 ) {\n      # pid has returned, remove it from our queue\n      my $status = $?;\n      my $finishedPdf = delete ($pdfRunningQueue{$pid});\n\n      $pdf->writePdfStats($status);\n\n      if ( $status != 0 ) {\n        if ( !defined $errors{PDF} ) {\n          $errors{PDF} = $pdf->{reportName};\n        } else {\n          $errors{PDF} .= \" $pdf->{reportName}\";\n        }\n        updateControl();\n        $exitStatus = 1;\n      }\n\n      cleanUpChildControl($p);\n\n      l(\"Removed PDF $pdf->{reportName} ($pid) from the pdfRunningQueue. Child return status: $status. Duration: $pdf->{reportStats}{pdfDur}.\");\n      push @endQueue, $pdf;\n      l(\"Added $pdf->{reportName} to endQueue\");\n    } else {\n      l(\"PDF $pdf->{reportName} ($pid, $p) is still running.\", 3);\n    }\n  }\n}\n\nsub printState {\n  my ($state) = @_;\n  $state = 0 if not defined $state;\n  my $printString;\n\n  l(\"Printing state of all sproc and PDF queues\", $state);\n\n  $printString = \"\";\n  for my $report ( @sprocQueue ) {\n    $printString .= \"\\n\\t$report->{reportName}\";\n  }\n  l(\"sprocQueue:$printString\", $state);\n\n  $printString = \"\";\n  foreach my $report ( values %sprocRunningQueue ) {\n    $printString .= \"\\n\\t$report->{reportName}\";\n  }\n  l(\"sprocRunningQueue:$printString\", $state);\n\n  $printString = \"\";\n  for my $report ( @pdfQueue ) {\n    $printString .= \"\\n\\t$report->{reportName}\";\n  }\n  l(\"pdfQueue:$printString\", $state);\n\n  $printString = \"\";\n  foreach my $report ( values %pdfRunningQueue ) {\n    $printString .= \"\\n\\t$report->{reportName}\";\n  }\n  l(\"pdfRunningQueue:$printString\", $state);\n\n  $printString = \"\";\n  for my $report ( @endQueue ) {\n    $printString .= $report->state();\n  }\n  l(\"endQueue:\\n $printString\", $state);\n}\n\nsub printPerformance {\n  my $printString = \"################## Report Run Performance Report ##################\";\n  my $limit       = $maxPerformanceDisp - 1;\n  my @sortedEndQueue = sort { $b->{reportStats}{sprocDur} <=> $a->{reportStats}{sprocDur} } @endQueue;\n\n  if ($details{SPROCS_ENABLED}) {\n    $printString   .= \"\\n Top $maxPerformanceDisp worst performing sprocs:\\n\";\n    for my $report ( @sortedEndQueue ) {\n      $printString .= \"\\t$report->{sprocName} $report->{reportStats}{sprocDur}\\n\";\n      last if !$limit;\n      $limit--;\n    }\n\n    $printString .= \"\\n Failed sprocs:\\n\";\n    for my $report ( @sortedEndQueue ) {\n      if ( ($report->{reportStats}{sprocRet}) ) {\n        $printString .= \"\\t$report->{sprocName}: $report->{reportStats}{sprocRet}\\n\";\n      }\n    }\n  }\n\n  if ($details{PDFS_ENABLED}) {\n    $printString .= \"\\n Top $maxPerformanceDisp worst performing PDFs:\\n\";\n    $limit        = $maxPerformanceDisp - 1;\n    @sortedEndQueue = sort { $b->{reportStats}{pdfDur} <=> $a->{reportStats}{pdfDur} } @endQueue;\n    for my $report ( @sortedEndQueue ) {\n      $printString .= \"\\t$report->{reportName} $report->{reportStats}{pdfDur}\\n\";\n      last if !$limit;\n      $limit--;\n    }\n\n    $printString .= \"\\n Failed PDFs:\\n\";\n    for my $report ( @sortedEndQueue ) {\n      if ( ($report->{reportStats}{pdfRet}) ) {\n        $printString .= \"\\t$report->{pdfFileName}: $report->{reportStats}{pdfRet}\\n\";\n      }\n    }\n  }\n\n  $printString .= \"###################################################################\";\n  l(\"\\n$printString\\n\");\n}\n\nsub getReportList {\n  my @reportList = ();\n\n  if (defined $details{RERUN_REPORT_LIST}) {\n    l(\"Getting Selective Report List\");\n    my $sth = $pDbh->prepare(\"select SPROC_NAME, CACHE_NAME, RPT_NAME from iTB_report_list where REPORT_TYPE = ? and RPT_NAME = ?\");\n    foreach my $report (@{$details{RERUN_REPORT_LIST}}) {\n      $sth->execute($details{TYPE}, \"[$report]\");\n      my $foundReport = 0;\n      while (my $row = $sth->fetchrow_hashref()) {\n        my $reportName = $row->{RPT_NAME};\n        $reportName =~ s/[\\[\\]]//g;\n\n        my $reportObj = new Report( {\n          reportName  => $reportName,\n          sprocName   => $row->{SPROC_NAME},\n          cacheName   => $row->{CACHE_NAME},\n          pdfFileName => \"$reportName.$details{EXT}\",\n          details     => \\%details\n        } );\n\n        # Set status of either PDF or sproc to complete if they are disabled\n        $reportObj->{sprocStatus} = \"COMPLETE\" if !$details{SPROCS_ENABLED};\n        $reportObj->{pdfStatus}   = \"COMPLETE\" if !$details{PDFS_ENABLED};\n        push @reportList, $reportObj;\n        $foundReport++;\n      }\n      if ($foundReport == 0) {\n        l(\"Could not find $report as provided in the rerun report list\", 1);\n      }\n    }\n    $sth->finish();\n  } else {\n    l(\"Getting Report List\");\n\n    my $sth = $pDbh->prepare('select SPROC_NAME, CACHE_NAME, RPT_NAME from iTB_report_list where ACTIVE = \"Y\" and REPORT_TYPE = \"D\"');\n    #$sth->execute($details{TYPE});\n    $sth->execute();\n\n    my $dbh = $details{util}->newDbh();\n    my $statSth = $dbh->prepare($initStatSql);\n\n    while( my $report = $sth->fetchrow_hashref() ) {\n      my $reportName = $report->{RPT_NAME};\n      $reportName =~ s/[\\[\\]]//g;\n\n      my $reportObj = new Report( {\n        reportName  => $reportName,\n        sprocName   => $report->{SPROC_NAME},\n        cacheName   => $report->{CACHE_NAME},\n        pdfFileName => \"$reportName.$details{EXT}\",\n        details     => \\%details\n      } );\n\n      # Set status of either PDF or sproc to complete if they are disabled\n      $reportObj->{sprocStatus} = \"COMPLETE\" if !$details{SPROCS_ENABLED};\n      $reportObj->{pdfStatus}   = \"COMPLETE\" if !$details{PDFS_ENABLED};\n\n      $statSth->execute(\n        $details{ACTIVITY_DATE}, $details{MPID}, $reportObj->{reportName}, $reportObj->{sprocName},\n        $details{ACTIVITY_DATE}, $details{MPID}, $reportObj->{reportName}, $reportObj->{sprocName},\n        $details{ACTIVITY_DATE}, $details{MPID}, $reportObj->{reportName}, $reportObj->{sprocName}\n      ) if !$details{RERUN_MODE};\n      $statSth->fetch();\n\n      push @reportList, $reportObj;\n    }\n    $sth->finish();\n  }\n  return @reportList;\n}\n\nsub initConflictingSprocs {\n  my $getTempdbSql = 'select db_name = db_name(@@tempdbid)';\n\n  my $cdbh = $details{util}->newCentralDBH();\n\n  if ( !defined $cdbh ) {\n    l(\"Could not connect to central table STATS_DB..CONFLICTING_REPORTS.  There will be NO conflicting report detection in this report run\", 2);\n    return 1;\n  }\n\n  eval {\n    my @result = $pDbh->syb_nsql($getTempdbSql, \"HASH\");\n    if ( @result ) {\n      # Only if this returns a row should we change $userTempdb from 'tempdb'\n      $userTempdb = $result[0]->{db_name};\n      chomp($userTempdb);\n    }\n    l(\"Setting users tempdb to '$userTempdb' for conflicting sproc detection\");\n  };\n  if ( $@ ) {\n    l(\"There was an unexpected error determining users tempdb, continuing using default of '$userTempdb'.\\n\\tError: $@\", 2);\n  }\n\n  # Pull table from central database\n  eval {\n    l(\"Gathering reports from central STATS_DB..CONFLICTING_REPORTS table\");\n    my $sth = $cdbh->prepare(\"select SPROC_NAME, CONFLICTING from STATS_DB..CONFLICTING_REPORTS\");\n    $sth->execute();\n    while ( my $row = $sth->fetchrow_hashref() ) {\n      push @{ $conflictingCheck{$row->{SPROC_NAME}} }, $row->{CONFLICTING};\n      push @{ $conflictingCheck{$row->{CONFLICTING}} }, $row->{SPROC_NAME};\n    }\n    @conflictingSprocs = keys %conflictingCheck;\n\n    # Make sure we check if the keyed sprocs are running as well\n    for my $key ( keys %conflictingCheck ) {\n      push @{ $conflictingCheck{$key} }, $key;\n    }\n\n    l(\"Contents of hash used to check for conflicting sprocs:\\n\" . Dumper(\\%conflictingCheck), 3);\n    $sth->finish();\n    $cdbh->disconnect();\n  };\n  if ( $@ ) {\n    l(\"There was an unexpected error getting conflicting sproc information from the central table STATS_DB..CONFLICTING_REPORTS.  Report run will continue with conflicting reports we have gathered so far.\\n\\tError: $@\", 2);\n  }\n\n  l(\"The following sprocs will be checked in sysprocesses for conflicts (within $userTempdb):\\n\\t\" . join(\"\\n\\t\", @conflictingSprocs));\n}\n\nsub initSprocOptions {\n\n  my $cdbh = $details{util}->newCentralDBH();\n\n  if ( !defined $cdbh ) {\n    l(\"Could not connect to central table STATS_DB..SPROC_OPTIONS.  No extra settings (opt goal, merge joins, etc) will be applied to any sprocs for this report run.\", 2);\n    return 1;\n  }\n\n  eval {\n    l(\"Gathering extra settings that should be run for certain sprocs from central STATS_DB..SPROC_OPTIONS table\");\n    # We will do this in 3 steps (priorities).  Each step will overwrite the GOAL column or append the OPTIONS column if it already exists.\n    # The first (pri3) gets specifc MPID and ALL sproc combinations, second (pri2) gets ALL MPID and specific sproc combinations and the last (pri1) getting specific MPID and specific SPROC combinations.\n    # The pri3(MPID/ALL) OPTIONS field is handled outside of this block in the runSproc sub so that it can be prepended to every report.\n    # This defines the precedence of difference SPROC_OPTIONS combinations. Please note that an ALL/ALL combination is not supported, please use server-wide settings to accomplish this. Anything defined as ALL/ALL in the table will be ignored and you will be disappointed.\n    my @execArr = (\n      ['select * from STATS_DB..SPROC_OPTIONS where MPID = ? and SPROC_NAME  = \"ALL\"', $details{MPID}], # Pri3\n      ['select * from STATS_DB..SPROC_OPTIONS where MPID = ? and SPROC_NAME <> \"ALL\"', \"ALL\"],          # Pri2\n      ['select * from STATS_DB..SPROC_OPTIONS where MPID = ? and SPROC_NAME <> \"ALL\"', $details{MPID}]  # Pri1\n    );\n    foreach my $queryArr (@execArr) {\n      my $sth = $cdbh->prepare(@{$queryArr}[0]);\n      $sth->execute(@{$queryArr}[1]);\n      while ( my $row = $sth->fetchrow_hashref() ) {\n        if (defined $details{SPROC_OPTIONS}{$row->{SPROC_NAME}}{OPTIONS} && defined $row->{OPTIONS}) {\n          $details{SPROC_OPTIONS}{$row->{SPROC_NAME}}{OPTIONS} .= \"\\n$row->{OPTIONS}\";\n        } elsif (defined $row->{OPTIONS}) {\n          $details{SPROC_OPTIONS}{$row->{SPROC_NAME}}{OPTIONS} = \"$row->{OPTIONS}\"\n        }\n        if (defined $row->{OPT_GOAL}) {\n          $details{SPROC_OPTIONS}{$row->{SPROC_NAME}}{OPT_GOAL} = $row->{OPT_GOAL};\n        }\n      }\n      $sth->finish();\n    }\n  };\n  if ( $@ ) {\n    l(\"There was an unexpected error gathering the list of extra sproc options that should be applied to specific sprocs: $@\", 1);\n  }\n\n  my $sprocOptionString = \"\";\n  for my $sproc ( keys %{ $details{SPROC_OPTIONS} } ) {\n    $sprocOptionString .= \"\\n\\t$sproc\";\n    $sprocOptionString .= \"\\n\\t    Optimization Goal: $details{SPROC_OPTIONS}{$sproc}{OPT_GOAL}\" if defined $details{SPROC_OPTIONS}{$sproc}{OPT_GOAL}; #ne \"\";\n    $sprocOptionString .= \"\\n\\t    Misc Options:      $details{SPROC_OPTIONS}{$sproc}{OPTIONS}\"  if defined $details{SPROC_OPTIONS}{$sproc}{OPTIONS}; #ne \"\";\n  }\n  l(\"The following sprocs will have extra options applied to them at run time:$sprocOptionString\");\n\n  $cdbh->disconnect();\n}\n\nsub updateStats {\n  l(\"Updating statistics as 'sa'\");\n\n  l(\"Updating statistics on TB_TODAYS_TRADES\");\n  $saDbh->do(\"update all statistics TB_TODAYS_TRADES\");\n  $saDbh->do(\"sp_recompile TB_TODAYS_TRADES\");\n\n  l(\"Updating statistics on TB_TODAYS_ORDERS\");\n  $saDbh->do(\"update all statistics TB_TODAYS_ORDERS\");\n  $saDbh->do(\"sp_recompile TB_TODAYS_ORDERS\");\n\n  l(\"Updaintg index statistics on important order and trade tables\");\n  foreach my $table (@updateStatsTables) {\n    l(\"Updating statistics on $table\");\n    $saDbh->do(\"update index statistics $table\");\n  }\n}\n\n# Call main driver.  Script entry point.\ngetopts('ep:r:m:t:d:S:U:P:ACflRaL:b:sgy:o:hD', \\%opts);\nexit main();\n\n}\n\n{\n  package Util;\n  use strict;\n  use warnings;\n\n  sub new {\n    my ($class, $detailsRef)  = @_;\n    my %details               = %$detailsRef;\n    my $self = bless {\n      sybaseServer            => $details{ASE_NAME},\n      sybaseUser              => $details{USERNAME},\n      sybasePass              => $details{PASSWORD},\n      sybaseDb                => $details{DATABASE},\n      sybaseDsn               => \"dbi:Sybase:server=$details{ASE_NAME};database=$details{DATABASE};dbi:Sybase:loginTimeout=180\",\n      sybaseCentralServer     => $details{CENTRAL_DB_DETAILS}{ASE_NAME},\n      sybaseCentralHost       => $details{SYB_PRIMARY_HOST},\n      sybaseCentralUser       => $details{CENTRAL_DB_DETAILS}{USERNAME},\n      sybaseCentralPass       => $details{CENTRAL_DB_DETAILS}{PASSWORD},\n      sybaseCentralDb         => $details{CENTRAL_DB_DETAILS}{DATABASE},\n      sybaseCentralDsn        => \"dbi:Sybase:server=$details{CENTRAL_DB_DETAILS}{ASE_NAME};database=$details{CENTRAL_DB_DETAILS}{DATABASE};dbi:Sybase:loginTimeout=180;interfaces=/usr/local/fidessa/thirdparty/sybase_LINUX_X86/interfaces\",\n    }, $class;\n    return $self;\n  }\n\n  sub newDbh {\n    my ($self, $user, $pass) = @_;\n\n    $user = $user || $self->{sybaseUser};\n    $pass = $pass || $self->{sybasePass};\n\n    my $dbh;\n    my %attr = (\n      syb_err_handler           => \\&Util::err_handler,\n      syb_show_sql              => 1,\n      syb_show_eed              => 1,\n      syb_deadlock_retry        => 3,   # Retry up to 3 times after deadlock situation\n      syb_deadlock_sleep        => 10,  # Sleep for 10 seconds before retrying deadlock\n      RaiseError                => 1,\n      #syb_disconnect_in_child  => 1,\n      #AutoCommit               => 0,   # Enable explicitly commiting or rolling back transactions\n      syb_chained_txn           => 0,   # Ensure we are in unchained mode\n      syb_nsql_nostatus         => 1    # Prevent sproc return status\n    );\n    $dbh = DBI->connect($self->{sybaseDsn}, $user, $pass, \\%attr) or die \"Could not conenct to database $self->{SybaseDb}:\" . $dbh->errstr;\n    return $dbh;\n  }\n\n  sub newCentralDBH {\n    my ($self) = @_;\n    my %attr = (\n      syb_err_handler         => \\&Util::err_handler,\n      syb_show_sql            => 1,\n      syb_show_eed            => 1,\n      syb_deadlock_retry      => 3,   # Retry up to 3 times after deadlock situation\n      syb_deadlock_sleep      => 10,  # Sleep for 10 seconds before retrying deadlock\n      RaiseError              => 1,\n      syb_disconnect_in_child => 1,\n      AutoCommit              => 0,   # Enable explicitly commiting or rolling back transactions\n      syb_chained_txn         => 0,   # Ensure we are in unchained mode\n      syb_nsql_nostatus       => 1    # Prevent sproc return status\n    );\n\n    my $cdbh;\n    eval {\n      $cdbh = DBI->connect(\n        $self->{sybaseCentralDsn},\n        $self->{sybaseCentralUser},\n        $self->{sybaseCentralPass},\n        \\%attr\n      ) or die \"Could not connect to central database to gather PDF generator hosts:\" . $cdbh->errstr;\n    };\n    if ( $@ ) {\n      main::l(\"There was a problem making a connection to $self->{sybaseCentralHost}\", 1);\n      return;\n    }\n    return $cdbh;\n  }\n\n  sub err_handler {\n    my($err, $sev, $state, $line, $server,\n      $proc, $msg, $sql, $err_type) = @_;\n\n    my @msg = ();\n    if ( $err_type eq 'server' ) {\n      push @msg, (\n        '',\n        'Server message',\n        sprintf('Message number: %ld, Severity %ld, State %ld, Line %ld', $err, $sev, $state,$line),\n        (defined($server) ? \"Server '$server' \" : '') .  (defined($proc) ? \"Procedure '$proc'\" : ''),\n        \"Message String:$msg\"\n      );\n    } else {\n      push @msg, (\n        '',\n        'Open Client Message:',\n        sprintf('Message number: SEVERITY = (%ld) NUMBER = (%ld)', $sev, $err),\n        \"Message String: $msg\"\n      );\n    }\n    my $logLevel = 0;\n    if ( defined($proc) ) {\n      chomp($msg);\n      main::l(\"$$ [SYB $proc] $msg\");\n    } else {\n      main::l(join(\"\\n$$ [SYB]\", @msg), $logLevel);\n    }\n    return 0; ## CS_SUCCEED\n  }\n}\n\n{\n  package Report;\n  use strict;\n  use warnings;\n  use Data::Dumper;\n\n  sub new {\n    my ($class, $args) = @_;\n    my $self = bless {\n      reportName    => $args->{reportName},\n      sprocName     => $args->{sprocName},\n      pdfFileName   => $args->{pdfFileName},\n      cacheName     => $args->{cacheName},\n      details       => $args->{details},\n      sprocStatus   => \"PENDING\",\n      pdfStatus     => \"PENDING\",\n      depotResult   => 0,\n      depotRunning  => 0,\n      #pid           => $$,\n      reportStats => {\n        sprocDur => 0,\n        pdfDur   => 0,\n        },\n    }, $class;\n\n    initStatsQueries($self);\n\n    return $self;\n  }\n\n  sub state {\n    my ($self)        = @_;\n    my $totalDur      = $self->{reportStats}{sprocDur} + $self->{reportStats}{pdfDur};\n    my $sprocSuccess  = ( $self->{reportStats}{sprocRet} ? \"Failed\" : \"Succeeded\" );\n    my $pdfSuccess    = ( $self->{reportStats}{pdfRet} ? \"Failed\" : \"Succeeded\" );\n    my $timedOut      = ( $self->{reportStats}{timedOut} ? \"True\" : \"False\" );\n    my $timedOutVal   = $self->{reportStats}{timedOut};\n    if ( !defined $self->{reportStats}{timedOut} ) {\n      $timedOutVal    = 0;\n    }\n\n    my $returnString  = \"\nReport: $self->{reportName}\n  Sproc:          $self->{sprocName}\n  File:           $self->{pdfFileName}\n  Cache:          $self->{cacheName}\n  Sproc success:  $sprocSuccess\n  Pdf success:    $pdfSuccess\n  Timed out:      $timedOut\n  Timed out val:  $timedOutVal\n  Statistics\n    Sproc duration: $self->{reportStats}{sprocDur}\n    Pdf duration:   $self->{reportStats}{pdfDur}\n    Total duration: $totalDur\\n\";\n\n    return $returnString;\n  }\n\n  sub runSproc {\n    # runSproc will attempt to run the sproc for a Report object\n    # This should only be called from within a child process (after a fork)\n    my $self        = shift;\n    my $sprocRetVal = 0;\n    my $dbh         = $self->{details}{util}->newDbh();\n    my %details     = %{$self->{details}};\n\n    if ( $self->{sprocStatus} ne \"COMPLETE\" ) {\n      # Confirm we are running sproc in the correct database\n      my $sth = $dbh->prepare(\"select db_name()\");\n      $sth->execute();\n      my $dbname = $sth->fetchrow_array();\n      $sth->finish();\n      if ( $dbname ne $self->{details}{DATABASE} ) {\n        main::l(\"$$ $self->{sprocName} $dbname does not match $self->{details}{DATABASE}\", 2);\n        exit(1);\n      }\n\n      $dbh->do($self->{setSprocStart}, undef, $details{ACTIVITY_DATE}, $details{MPID}, $self->{sprocName} ) if !$details{RERUN_MODE};\n      $dbh->do(\"set flushmessage on\");\n      $sth = $dbh->prepare('select @@spid');\n      $sth->execute();\n      my $spid = $sth->fetchrow_array();\n      $sth->finish();\n\n      my $childSaDbh; # Only initialized if we are logging reads\n      my $readsBefore;\n      if ( $details{LOG_READS} ) {\n        $childSaDbh = $details{util}->newDbh($details{SA_DETAILS}->{USERNAME}, $details{SA_DETAILS}->{PASSWORD});\n        $sth = $childSaDbh->prepare('select LogicalReads from master..monProcessActivity where SPID = ?');\n        $sth->execute($spid);\n        $readsBefore = $sth->fetchrow_array();\n        $sth->finish();\n      }\n\n      my $sprocOptionSql = $self->getSprocOptionSql();\n      main::l(\"$$ $self->{sprocName} Adding the following extra runtime options:\\n$sprocOptionSql\") if $sprocOptionSql ne \"\";\n\n      main::l(\"$$ $self->{sprocName} started, spid: $spid\");\n      my $statement = \"$sprocOptionSql\\n exec $self->{sprocName} \\@activity_date = '$self->{details}{ACTIVITY_DATE}' \";\n      $sth = $dbh->prepare($statement);\n      $sth->execute();\n\n      if ( $details{LOG_READS} ) {\n        $sth = $childSaDbh->prepare('select LogicalReads from master..monProcessActivity where SPID = ?');\n        $sth->execute($spid);\n        my $readsAfter = $sth->fetchrow_array();\n        $sth->finish();\n        $childSaDbh->disconnect();\n        main::l(\"$$ $self->{sprocName} performed \" . ($readsAfter-$readsBefore) . \" logical reads\");\n      }\n\n      do {\n        my $rt = $sth->{syb_result_type};\n        while( my @row = $sth->fetchrow_array() ) {\n          if ( $rt == 4040 ) {\n            main::l(\"$$ SPROC OUTPUT: $self->{reportName} $#row $row[0]\");\n          } elsif ( $rt == 4042 ) {\n            main::l(\"$$ SPROC PARAM: $self->{reportName} $row[0]\");\n          } elsif ( $rt == 4043 ) {\n            $sprocRetVal = $row[0];\n          } elsif ( $rt == 4044 ) {\n            main::l(\"$$ SPROC MSG: $self->{reportName} $row[0]\");\n          }\n        }\n      } while ( $sth->{syb_more_results} );\n\n      if ( $sprocRetVal != 0 || $sprocRetVal eq \"\" ) {\n        main::l(\"$$ $self->{sprocName} returned with status: $sprocRetVal\", 1);\n      } else {\n        main::l(\"$$ $self->{sprocName} returned with status: $sprocRetVal\");\n      }\n      $sth->finish();\n      $dbh->do($self->{setSprocEnd}, undef, $details{ACTIVITY_DATE}, $details{MPID}, $self->{sprocName} ) if !$details{RERUN_MODE};\n\n      my @result = $dbh->selectrow_array($self->{updateRowCount}, undef, $details{ACTIVITY_DATE}, $details{MPID}, $self->{sprocName}) if !$details{RERUN_MODE};\n      my $count = $result[0];\n      main::l(\"$$ $self->{sprocName} resulted in \" . (defined $count ? $count : 0 ) . \" rows in $self->{cacheName}\", 0);\n\n    } else {\n      main::l(\"$$ $self->{sprocName} was already run for another report, skipping.  Current sproc status: $self->{sprocStatus}\");\n    }\n    $dbh->disconnect();\n    return $sprocRetVal;\n  }\n\n  sub runPdf {\n    # runPdf will attempt to generate a pdf for a Report object\n    # This should only be called from within a child process (after a fork).\n    my ($self)        = @_;\n    my $pdfRetVal     = 0;\n    my $foundSuccess  = 0;\n    my $dbh           = $self->{details}{util}->newDbh();\n    my %details       = %{$self->{details}};\n    my $timeout       = $details{CENTRAL_PDF_TIMEOUT_WARN}/$details{CENTRAL_PDF_SLEEP};  # Convert timeout to number of iterations based on sleep seconds\n    my @retryErrors   = (\"Permission denied\", \"Connection timed out\", \"ssh_exchange_identification: Connection closed by remote host\", \"node name or service name not known\", \"Connection closed by\", \"Connection reset by peer\");\n    my $maxRetries    = $details{MAX_PDF_RETRY};\n    my $errorText     = \"\";\n    my $retryDelay    = $details{PDF_RETRY_SLEEP};\n    my $pdfHost;\n\n    do {\n      $errorText    = \"\";\n      $pdfRetVal    = 0;\n      $foundSuccess = 0;\n\n      eval {\n        while ( !($pdfHost = $self->startPdfCentral()) ) {\n          if ( $timeout <= 0 ) {\n            main::l(\"$$ It has been approximately $details{CENTRAL_PDF_TIMEOUT_WARN} seconds since we were last able to find an available host to generate PDFs\", 1);\n            main::l(\"$$ It has been longer than the warning threshold of $details{CENTRAL_PDF_TIMEOUT_WARN} seconds while trying to find an available host to generate PDF $self->{pdfFileName}\", 1);\n\n            main::updateControl(\"STARTPDF\", \"WARNING: Unable to grab an available PDF host for over $details{CENTRAL_PDF_TIMEOUT_WARN} seconds\\n\");\n          }\n\n          main::l(\"$$ runPdf: No available hosts.  Trying again in $details{CENTRAL_PDF_SLEEP} seconds\", 0);\n          $timeout--;\n          sleep $details{CENTRAL_PDF_SLEEP};\n        }\n\n        my $cmd = \"$details{SSH} $pdfHost->{USERNAME}\\@$pdfHost->{HOSTNAME} '/Rpt/GenPdfWrapper_V4.pl -m $details{MPID} -r $self->{reportName} -S $details{ASE_NAME} -D $details{DATABASE} -U $details{USERNAME} -P $details{PASSWORD} -n $self->{pdfFileName} -h $details{PDF_DESTINATION_HOST} -l $details{PDF_DESTINATION_BASE}/$details{MPID} -u $details{PDF_DESTINATION_USER}'\";\n\n        main::l(\"$$ $self->{pdfFileName} sent to $pdfHost->{USERNAME}\\@$pdfHost->{HOSTNAME}\", 0);\n        ##################################################################\n\n        $dbh->do( $self->{setPdfStart}, undef, $details{ACTIVITY_DATE}, $details{MPID}, $self->{reportName}, $self->{sprocName} ) if !$details{RERUN_MODE};\n\n        main::l(\"$$ \".$cmd,0);\n        open my $out, \"$cmd 2>&1 |\" or $pdfRetVal = 1;\n        while ( <$out> ) {\n          chomp;\n          my $line = $_;\n          main::l(\"$$ SSH $line\");\n          if ( /^SUCCESS:/ ) {\n            $foundSuccess++;\n          }\n          if ( grep {$line =~ /\\Q$_\\E/} @retryErrors ) {\n            # Search for any retryable errors in the output\n            $errorText = $line;\n          }\n        }\n        close($out) or $pdfRetVal = 1;\n        my $exit = $?;\n        if ( $exit ) {\n          $pdfRetVal = $exit;\n          main::l(\"$$ GenPdfWrapper returned status $exit\", 1);\n        }\n      };\n\n      if ( $@ ) {\n        main::l(\"$$ $self->{reportName} encountered an error and could not be sent: $@\", 1);\n        $pdfRetVal = 1;\n      } elsif ( $? > 0 || $foundSuccess == 0 || $pdfRetVal > 0 ) {\n        main::l(\"$$ SSH There was an error producing $self->{reportName}\", 1);\n        $pdfRetVal = 1;\n      }\n\n      main::l(\"$$ Ending PDF $self->{pdfFileName} that was sent to $pdfHost->{USERNAME}\\@$pdfHost->{HOSTNAME}\", 0);\n      $self->endPdfCentral($pdfHost->{HOSTNAME});\n\n      $dbh->do( $self->{setPdfEnd}, undef, $details{ACTIVITY_DATE}, $details{MPID}, $self->{reportName}, $self->{sprocName} ) if !$details{RERUN_MODE};\n\n      $maxRetries--;\n      if ( $foundSuccess && $errorText eq \"\" ) {\n        # PDF generation succeeded and there are no retryable errors\n        $maxRetries = -1;\n      } elsif ( $errorText ne \"\" ) {\n        # PDF generation did not succeed and there is a retryable error\n        my $retryNum = $details{MAX_PDF_RETRY} - $maxRetries;\n        main::l(\"$$ PDF $self->{reportName} failed with a retry-able error, attempt $retryNum/$details{MAX_PDF_RETRY} in $retryDelay seconds:\\n                          $errorText\");\n        sleep($retryDelay);\n      } else {\n        main::l(\"$$ PDF $self->{reportName} failed, but the error was not retry-able:\\n                          $errorText\", 3);\n        $maxRetries = -1;\n      }\n    } while ( $maxRetries > 0 );\n\n    if ( $maxRetries == 0 && !$foundSuccess ) {\n      main::l(\"$$ Reached the max number of retries without successfully generating PDF $self->{reportName}\");\n    }\n\n    $dbh->disconnect();\n    return $pdfRetVal;\n  }\n\n  sub writeSprocStats {\n    my ($self, $status) = @_;\n\n    $self->setSprocRet($status);\n    $self->{reportStats}{sprocEnd} = time;\n    $self->{reportStats}{sprocDur} = $self->{reportStats}{sprocEnd} - $self->{reportStats}{sprocStart};\n  }\n\n  sub writePdfStats {\n    my ($self, $status) = @_;\n\n    $self->setPdfRet($status);\n    $self->{reportStats}{pdfEnd} = time;\n    $self->{reportStats}{pdfDur} = $self->{reportStats}{pdfEnd} - $self->{reportStats}{pdfStart};\n  }\n\n  sub setSprocRet {\n    my ($self, $sprocRet) = @_;\n\n    $self->{reportStats}{sprocRet} = $sprocRet;\n  }\n\n  sub setPdfRet {\n    my ($self, $pdfRet) = @_;\n\n    $self->{reportStats}{pdfRet} = $pdfRet;\n  }\n\n  sub checkSprocTimeout {\n    my ($self, $timeout) = @_;\n    my $curTime = time;\n\n    if ( ($curTime - $self->{reportStats}{sprocStart}) >= $timeout && ! defined $self->{reportStats}{timedOut} ) {\n      $self->{reportStats}{timedOut} = 1;\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n  sub startPdfCentral {\n    # Attempts to get an available PDF generation PC from the central table and mark it running.\n    # If it does not find an available PC it returns undefined or an empty array.  In fallback mode it returns the values specified in the SysDef.\n    my ($self)                      = @_;\n    my %details                     = %{$self->{details}};\n    my ($pdfName, $activityDate,\n        $server, $database, $mpid)  = ($self->{pdfFileName}, $details{ACTIVITY_DATE},\n                                      $details{ASE_NAME}, $details{DATABASE}, $details{MPID});\n\n    my $sql = \"\n  exec sp_fidessa_start_pdf\n    \\@pdfName      = ?,\n    \\@activityDate = ?,\n    \\@serverName   = ?,\n    \\@databaseName = ?,\n    \\@mpid         = ?\";\n\n    my @result;\n    if ( !$details{CENTRAL_FALLBACK} && (my $cdbh = $self->{details}{util}->newCentralDBH()) ) {\n      eval {\n        my @args = ($pdfName, $activityDate, $server, $database, $mpid);\n        my %options = ( 'arglist' => \\@args, );\n        @result = $cdbh->syb_nsql($sql, \"HASH\", \\%options);\n      };\n      if ( $@ ) {\n        main::l(\"$$ There was a problem executing a query in startPdfCentral for PDF $pdfName, transaction will be rolled back: \" . $cdbh->err . \": \" . $cdbh->errstr, 1);\n        main::l(\"$$ Error: $@\", 1);\n        main::l(\"$$ Offending query: $sql\", 1);\n        $cdbh->rollback();\n        die \"$$ Problem executing query on $details{CENTRAL_HOST} and has been rolled back.\";\n      } elsif (scalar @result > 1) {\n        main::l(\"$$ Query for startPdfCentral returned more than one row for PDF $pdfName, rolling back transaction\", 1);\n        main::l(\"$$ Rows: \" . Dumper(@result), 1);\n        main::l(\"$$ Offending query: $sql\", 1);\n        $cdbh->rollback();\n        die \"$$ Query returned more than one PDF generator host from $details{SYB_PRIMARY_HOST} and has been rolled back.\";\n      } else {\n        $cdbh->commit();\n      }\n      $cdbh->disconnect();\n    } elsif ( $details{CENTRAL_FALLBACK} ) {\n      $result[0]{USERNAME} = $details{PDF_GENERATOR_USER};\n      $result[0]{HOSTNAME} = $details{PDF_GENERATOR_HOST};\n    } else {\n      main::l(\"Falling back to default PDF host from SystemDefinition.cfg due to an issue with the database: $details{PDF_GENERATOR_USER}\\@$details{PDF_GENERATOR_HOST}\", 1);\n      $result[0]{USERNAME} = $details{PDF_GENERATOR_USER};\n      $result[0]{HOSTNAME} = $details{PDF_GENERATOR_HOST};\n    }\n    return $result[0];\n  }\n\n  sub endPdfCentral {\n    #  Attempts to mark a PDF completed in the central table.\n    my ($self, $hostname)           = @_;\n    my %details                     = %{$self->{details}};\n    my ($pdfName, $activityDate,\n        $server, $database)         = ( $self->{pdfFileName}, $details{ACTIVITY_DATE}, $details{ASE_NAME}, $details{DATABASE} );\n\n    my $sql = \"\n      exec sp_fidessa_end_pdf\n        \\@pdfName = ?,\n        \\@hostName = ?,\n        \\@activityDate = ?,\n        \\@serverName = ?,\n        \\@databaseName = ?\";\n\n    my @result;\n    if ( !$details{CENTRAL_FALLBACK} && (my $cdbh = $details{util}->newCentralDBH()) ) {\n      eval {\n        my @args = ($pdfName, $hostname, $activityDate, $server, $database);\n        my %options = ('arglist' => \\@args, );\n        @result = $cdbh->syb_nsql($sql, \"HASH\", \\%options);\n      };\n      if ( $@ ) {\n        main::l(\"$$ There was a problem executing a query in endPdfCentral for PDF $pdfName, transaction will be rolled back: \" . $cdbh->err . \": \" . $cdbh->errstr, 1);\n        main::l(\"$$ Error: $@\", 1);\n        main::l(\"$$ Offending query: $sql\", 1);\n\tmain::updateControl(\"ENDPDF\", \"ERROR: $$ There was a problem executing a query in endPdfCentral for PDF $pdfName, transaction will be rolled back: \" . $cdbh->err . \": \" . $cdbh->errstr . \"\\n\");\n        $cdbh->rollback();\n      } elsif (scalar @result >= 1) {\n        main::l(\"$$ Query returned rows for PDF $pdfName.  This was not expected and the transaction will be rolled back\", 1);\n        main::l(\"$$ Rows: \" . Dumper(@result), 1);\n        main::l(\"$$ Offending query: $sql\", 1);\n        $cdbh->rollback();\n\tmain::updateControl(\"ENDPDF\", \"$$ Query returned rows for PDF $pdfName.  This was not expected and the transaction was rolled back\\n\");\n      } else {\n        $cdbh->commit();\n      }\n      $cdbh->disconnect();\n    } elsif ( $details{CENTRAL_FALLBACK} ) {\n      # Running in fallback mode so we don't need to do anything and probably don't need to log anything because that's just annoying\n    } else {\n      main::l(\"Could not mark PDF $pdfName as ended due to problem connecting to database\", 1);\n      main::updateControl(\"ENDPDF\", \"Could not mark PDF $pdfName as ended due to problem connecting to database\\n\");\n    }\n  }\n\n  sub initStatsQueries {\n    my ($self)  = @_;\n    my %details = %{$self->{details}};\n\n    $self->{setSprocStart} = \"\n      update\n        STATS_DB..REPORT_STATISTICS\n      set\n        SPROC_START_DT  = getdate()\n      where\n        ACTIVITY_DATE   = ?\n        and CLIENT_CODE = ?\n        and SPROC_NAME  = ?\n    \";\n\n    $self->{setSprocEnd} = \"\n      update\n        STATS_DB..REPORT_STATISTICS\n      set\n        SPROC_END_DT    = getdate(),\n        SPROC_RUN_TIME  = datediff(ss, SPROC_START_DT, getdate())\n      where\n        ACTIVITY_DATE   = ?\n        and CLIENT_CODE = ?\n        and SPROC_NAME  = ?\n    \";\n\n    $self->{updateRowCount} = \"\n      declare \\@rowcount int\n      select \\@rowcount = count(*) from $self->{cacheName}\n      update\n        STATS_DB..REPORT_STATISTICS\n      set\n        ROW_COUNT       = \\@rowcount\n      where\n        ACTIVITY_DATE   = ?\n        and CLIENT_CODE = ?\n        and SPROC_NAME  = ?\n      select \\@rowcount\n    \";\n\n    $self->{setPdfStart} = \"\n      update\n        STATS_DB..REPORT_STATISTICS\n      set\n        PDF_START_DT    = getdate()\n      where\n        ACTIVITY_DATE   = ?\n        and CLIENT_CODE = ?\n        and PDF_NAME    = ?\n        and SPROC_NAME  = ?\n    \";\n\n    $self->{setPdfEnd} = \"\n      update\n        STATS_DB..REPORT_STATISTICS\n      set\n        PDF_END_DT      = getdate(),\n        PDF_RUN_TIME    = datediff(ss, PDF_START_DT, getdate())\n      where\n        ACTIVITY_DATE   = ?\n        and CLIENT_CODE = ?\n        and PDF_NAME    = ?\n        and SPROC_NAME  = ?\n    \";\n  }\n\n  sub getSprocOptionSql {\n    my ($self)  = @_;\n    my %details = %{$self->{details}};\n    # Handles SPROC_OPTIONS if they apply to the sproc that is about to execute.\n    # The optgoal is applied first followed by extra options that apply to ALL if they exist (pri3).\n    # If any other matching extra sproc options (that were prepended in a previous step, pri2 then pri1) are then applied.\n\n    my $sprocOptionSql = \"\";\n    if (defined $details{SPROC_OPTIONS}{$self->{sprocName}}{OPT_GOAL}) {\n      $sprocOptionSql = \"set plan optgoal $details{SPROC_OPTIONS}{$self->{sprocName}}{OPT_GOAL}\";\n    } elsif (defined $details{SPROC_OPTIONS}{ALL}{OPT_GOAL}) {\n      $sprocOptionSql = \"set plan optgoal $details{SPROC_OPTIONS}{ALL}{OPT_GOAL}\";\n    }\n    # Sproc options for ALL sprocs (pri3)\n    if (defined $details{SPROC_OPTIONS}{ALL}{OPTIONS}) {\n      my $nl = ($sprocOptionSql eq \"\") ? \"\" : \"\\n\";\n      $sprocOptionSql .= \"$nl$details{SPROC_OPTIONS}{ALL}{OPTIONS}\" if defined $details{SPROC_OPTIONS}{ALL}{OPTIONS};\n    }\n    # All other sproc options (pri2 then pri1, prepended earlier).\n    # These are cases where either the ALL MPID and sproc (pri1) matched or specific MPID and sproc (pri2) matched.\n    if (defined $details{SPROC_OPTIONS}{$self->{sprocName}}{OPTIONS}) {\n      my $nl = ($sprocOptionSql eq \"\") ? \"\" : \"\\n\";\n      $sprocOptionSql .= \"$nl$details{SPROC_OPTIONS}{$self->{sprocName}}{OPTIONS}\"\n    }\n    return $sprocOptionSql\n  }\n\n  sub updateReportRuns {\n    ##################################################################\n    # Connect to Sybase Depot page and increment number of report    #\n    # runs for this server/database.                                 #\n    ##################################################################\n    my ($self, $incrOrDecr) = @_;\n    my %details             = %{$self->{details}};\n    my $depotHost           = 'dc1-ryb-sup-361';\n    my $action              = \"\";\n    my $text                = \"\";\n    my $result              = 0;\n    my $errorText;\n\n    if ( $incrOrDecr eq 'I' ) {\n      $action = 'incrReportRun';\n      $text   = 'increment';\n    } elsif ( $incrOrDecr eq 'D' ) {\n      $action = 'decrReportRun';\n      $text   = 'decrement';\n    } else {\n      main::l(\"Must provide either 'I' or 'D' to updateReportRuns function\", 1);\n      return;\n    }\n\n    my $url = \"http://$depotHost/PublicData/Sybase/SybaseAPI.php?action=$action&targetServer=$details{ASE_NAME}&targetDatabase=$details{DATABASE}\";\n\n    if ( $incrOrDecr eq 'D' && $self->{depotRunning} == 0 ) {\n      # We have already successfully decremented the Sybase Depot page so we don't want to do it again\n      main::l(\"Already successfuly decremented report run on Sybase Depot page, do not need to do it again.\", 3);\n      return;\n    } elsif ( $incrOrDecr eq 'D' && $self->{depotResult} != 1 ) {\n      main::l(\"Incrementing report run on Sybase Depot page was unsuccessful earlier so we will not decrement.\", 1);\n      main::l(\"Result: $self->{depotResult}\", 1);\n      return;\n    } else {\n      eval {\n        my $sd = new IO::Socket::INET(  PeerAddr => $depotHost,\n                                        PeerPort => 80, Proto => 'tcp',\n                                        Timeout => 5\n                                     ) or die \"Could not connect to $depotHost to update the number of running PDFs: $!\";\n        print $sd \"GET $url HTTP/1.0\\r\\n\";\n        print $sd \"\\r\\n\";\n        while ( my $line = <$sd> ) {\n          chomp($line);\n          if ($line ne \"\") {\n            my @response = split(/\\|/, $line);\n            if ($response[0] eq \"RESULT\") {\n              $result      = $response[1];\n              $self->{depotResult} = $response[1];\n            } elsif ($response[0] eq \"ERROR\") {\n              $self->{depotResult} = -1;\n              $errorText   = \"$response[1]\";\n            }\n          }\n        }\n      };\n      if ( $@ ) {\n        $errorText   = $@;\n        chomp($errorText);\n        $result      = -1;\n        $self->{depotResult} = -1;\n      } else {\n        if ( $incrOrDecr eq 'I' ) {\n          $self->{depotRunning}++;\n        } else {\n          $self->{depotRunning}--;\n        }\n      }\n    }\n\n    if ( $result == 1 ) {\n      main::l(\"Successfully \" . $text . \"ed report runs on Sybase Depot page.\", 0);\n    } else {\n      main::l(\"We could not $text the number of report runs on the Sybase Depot page. result = $result\", 1);\n      main::l(\"Output: $errorText\", 1);\n      main::l(\"url: $url\", 1);\n    }\n  }\n}\n","markerStore":{"nextMarkerId":27,"markersById":{"0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","editorId":74,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true},"1":{"range":{"start":{"row":1618,"column":0},"end":{"row":1618,"column":26}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"2":{"range":{"start":{"row":1619,"column":0},"end":{"row":1619,"column":16}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"3":{"range":{"start":{"row":1620,"column":0},"end":{"row":1620,"column":24}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"4":{"range":{"start":{"row":1622,"column":0},"end":{"row":1622,"column":30}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"5":{"range":{"start":{"row":234,"column":0},"end":{"row":234,"column":54}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"6":{"range":{"start":{"row":552,"column":0},"end":{"row":552,"column":20}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"7":{"range":{"start":{"row":553,"column":0},"end":{"row":553,"column":10}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"8":{"range":{"start":{"row":554,"column":0},"end":{"row":554,"column":17}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"9":{"range":{"start":{"row":566,"column":0},"end":{"row":566,"column":20}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"10":{"range":{"start":{"row":567,"column":0},"end":{"row":567,"column":10}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"11":{"range":{"start":{"row":568,"column":0},"end":{"row":568,"column":17}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"12":{"range":{"start":{"row":580,"column":0},"end":{"row":580,"column":20}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"13":{"range":{"start":{"row":581,"column":0},"end":{"row":581,"column":10}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"14":{"range":{"start":{"row":582,"column":0},"end":{"row":582,"column":17}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"15":{"range":{"start":{"row":2,"column":0},"end":{"row":2,"column":53}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"16":{"range":{"start":{"row":14,"column":0},"end":{"row":14,"column":11}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"17":{"range":{"start":{"row":240,"column":2},"end":{"row":240,"column":37}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"18":{"range":{"start":{"row":277,"column":6},"end":{"row":277,"column":100}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"19":{"range":{"start":{"row":551,"column":2},"end":{"row":551,"column":90}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"20":{"range":{"start":{"row":565,"column":2},"end":{"row":565,"column":86}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"21":{"range":{"start":{"row":579,"column":2},"end":{"row":579,"column":75}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"22":{"range":{"start":{"row":726,"column":4},"end":{"row":726,"column":76}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"23":{"range":{"start":{"row":733,"column":4},"end":{"row":733,"column":66}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"24":{"range":{"start":{"row":754,"column":2},"end":{"row":754,"column":225}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"25":{"range":{"start":{"row":1564,"column":6},"end":{"row":1564,"column":159}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false},"26":{"range":{"start":{"row":1617,"column":8},"end":{"row":1617,"column":54}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside","maintainHistory":false}},"version":2},"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/doot/projects/execrep.pl","digestWhenLastPersisted":"1c98102e0ffe9ee6b8881a2e1997cd8f0c0e1537","preferredLineEnding":null,"deserializer":"TextBuffer","version":2}]},"workspace":{"deserializer":"Workspace","paneContainer":{"deserializer":"PaneContainer","version":1,"root":{"deserializer":"Pane","id":3,"items":[{"deserializer":"SettingsView","version":2,"activePanelName":"Updates","uri":"atom://config"},{"deserializer":"TextEditor","id":74,"softTabs":true,"displayBuffer":{"deserializer":"DisplayBuffer","id":75,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/doot/projects/execrep.pl","largeFileMode":false},"largeFileMode":false}}],"activeItemURI":"/Users/doot/projects/execrep.pl","focused":false,"flexScale":1},"activePaneId":3},"fullScreen":false,"packagesWithActiveGrammars":["language-perl","language-hyperlink","language-todo"]},"packageStates":{"browser-plus":{"history":[],"fav":[],"favIcon":{},"title":{},"resetAgain":true},"linter":{"scope":"File"},"preview-plus":{"previewState":"","viewState":[],"projectState":{"undefined":{"url":"http://localhost"},"/Users/doot/projects":{"base":"/Users/doot/projects","url":"http://localhost"}}},"term3":{"termViews":[]},"fuzzy-finder":{"/Users/doot/projects/execrep.pl":1447285978709},"metrics":{"sessionLength":102316827},"tabs":[{}],"tree-view":{"directoryExpansionStates":{"/Users/doot/projects":{"isExpanded":true,"entries":{"coursera":{"isExpanded":false,"entries":{}},"github":{"isExpanded":false,"entries":{}}}}},"selectedPath":"/Users/doot/projects/execrep.pl","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}